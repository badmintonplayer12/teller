Folder Structure
--------------------------------------------------
/
    CONTRIBUTING.md
    index.html
    info.txt
    package.json
    update-autocomplete.js
.github/
    PULL_REQUEST_TEMPLATE.md
.vscode/
    settings.json
css/
    base.css
    layout.css
    modal.css
    share.css
    splash.css
    stats.css
    tournament.css
docs/
    ARCHITECTURE.md
    ARCHITECTURE_TODO.md
    CONSOLIDATION_TODO.md
    ignore-files.md
    IMPLEMENTATION_ROADMAP.md
    README_transition.md
    REFACTOR_LOG.md
    utf8-guide.md
    prompts/
        feature-small.md
        fix-small.md
        README.md
        refactor-small.md
js/
    constants.js
    dom.js
    main.js
    services/
        firebase.js
        firebaseSync.js
        mutations.js
        namesStore.js
        storage.js
        tournament.js
        writeAccess.js
    state/
        matchState.js
    ui/
        autocomplete.js
        layout.js
        matchView.js
        menu.js
        modal.js
        namesModal.js
        session.js
        share.js
        splash.js
        statsView.js
        tournamentOverview.js
        tournamentSetup.js
    util/
        domUtils.js
        loadScript.js
scripts/
    loc-count.mjs


File Contents
--------------------------------------------------


CONTRIBUTING.md
File type: .md
# BadmintonTeller – Retningslinjer for endringer

Disse reglene gjelder alle PR-er, spesielt de som lages med AI (Cursor/ChatGPT).

----------------------------------------
## Typer PR
- **refactor:** Rydding/forenkling. *Ingen nye funksjoner* og *ingen endret oppførsel*.
- **feat:** Ny funksjonalitet eller endret brukeropplevelse.
- **fix:** Feilretting uten å endre eksisterende design.

## Krav til ALLE PR-er
- Hold endringen liten og avgrenset. Del heller opp.
- Dokumentér i PR-beskrivelsen:
  - Resultat av `lint` (OK/feil)
  - Linjetall (før/etter), eller et grovt estimat hvis du ikke kjører cloc
- Kort "manuell test"-sjekkliste (hva du trykket på for å verifisere at det virker).

## Ekstra for *refactor*
- **Ingen nye features.** Koden skal gjøre det samme som før, bare være renere.
- Gjenbruk eksisterende helpers (f.eks. `ui/modal`, `util/dom`, state-actions).
- Bytt inline styles til CSS-klasser der det er enkelt.
- Bevar navngiving og offentlige API-er så langt det går.

## Ekstra for *feat*
- Beskriv kort brukerhistorie/scenario ("Som spiller vil jeg …").
- Legg ved enkel test-sjekkliste som viser hva som er nytt.

## Stil
- Bruk modulstruktur (ui/core/util) og unngå duplisering.
- En funksjon = ett ansvar. Korte, tydelige navn.



--------------------------------------------------
File End
--------------------------------------------------


index.html
File type: .html
﻿<!DOCTYPE html> 
<html lang="no">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>Badminton Poengteller</title>
<link rel="stylesheet" href="./css/base.css">
<link rel="stylesheet" href="./css/layout.css">
<link rel="stylesheet" href="./css/modal.css">
<link rel="stylesheet" href="./css/stats.css">
<link rel="stylesheet" href="./css/splash.css">
<link rel="stylesheet" href="./css/share.css">
<link rel="stylesheet" href="./css/tournament.css">
<!--
vNext highlights
- RTDB path: games/<gameId> (no UID in URL). hostUid stored once, validated by rules.
- Anonymous Firebase auth; spectator needs only ?mode=spectator&game=ID
- Reliable realtime (ref.on('value') for spectator, throttled ref.set for control) + presence flag
- Play gate + separate, clean "Rediger navn" modal (with recent-name dropdowns)
- Long-press-to-decrement w/ suppression (no accidental +1 on mouse-up, Chrome/Win fix)
- Stats view toggle; QR share (qrcodejs) w/ copy/share; clear local storage; kebab pulse hint
- Scrollbars hidden in match view; autoscale digits; glow animations; set swap & autoswap @11 in set 3
-->

<style>
/* Prevent splash from showing at all for match URLs - pure CSS solution */
body[data-match-mode] {
  overflow: visible !important;
}

body[data-match-mode] #splashMask {
  display: none !important;
}

/* Ultra-aggressive fallback */
body.splash-open.no-splash {
  overflow: visible !important;
}

body.splash-open.no-splash #splashMask {
  display: none !important;
}
</style>
</head>
<body class="splash-open">

<script data-match-url data-hide-splash>
// Early router: Hide splash immediately for direct match links
(function(){
  try {
    var params = new URL(location.href).searchParams;
    var mode = params.get('mode');
    var game = params.get('game');
    
    if (mode && game && (mode === 'spectator' || mode === 'counter' || mode === 'cocounter')) {
      // ULTRA-AGGRESSIVE: Set data attribute BEFORE any DOM manipulation
      document.body.setAttribute('data-match-mode', mode);
      
      // Remove splash classes and hide mask immediately
      document.body.classList.remove('splash-open');
      document.body.classList.add('no-splash');
      
      var splashMask = document.getElementById('splashMask');
      if (splashMask) {
        splashMask.style.display = 'none';
        splashMask.classList.remove('show');
        splashMask.setAttribute('aria-hidden', 'true');
      }
      
      // Triple backup: Ensure splash stays hidden
      document.addEventListener('DOMContentLoaded', function() {
        var splashMask = document.getElementById('splashMask');
        if (splashMask) {
          splashMask.style.display = 'none';
          splashMask.classList.remove('show');
          splashMask.setAttribute('aria-hidden', 'true');
        }
      });
    }
  } catch(e) {
    // Ignore errors in URL parsing
  }
})();
</script>

<div id="sets" aria-live="polite">Sett: 0-0</div>

  <div id="splashMask" class="splashMask show" aria-hidden="false">
    <div class="splashPanel" role="dialog" aria-labelledby="splashTitle" aria-modal="true">
      <h1 id="splashTitle" class="splashTitle">Velg kampoppsett</h1>
      <p class="splashLead">Velg format før du starter</p>
      <div class="splashGroup" role="group" aria-label="Spillform">
        <button type="button" class="splashToggle active" data-discipline="single" aria-pressed="true">Singel</button>
        <button type="button" class="splashToggle" data-discipline="double" aria-pressed="false">Dobbel</button>
      </div>
      <div class="splashGroup" role="group" aria-label="Kampmodus">
        <button type="button" class="splashToggle active" data-mode="singleMatch" aria-pressed="true">Enkeltkamp</button>
        <button type="button" class="splashToggle" data-mode="tournament" aria-pressed="false">Turnering</button>
      </div>
      <button type="button" id="splashStartBtn" class="splashStart">Start</button>
      <button type="button" id="splashContinueBtn" class="splashContinue" style="display:none">Fortsett pågående kamp</button>
    </div>
  </div>

<div id="tournamentMask" class="modalMask fullscreen" style="display:none" aria-hidden="true">
  <div class="modalPanel fullscreenPanel tournamentSetupPanel" role="dialog" aria-labelledby="tournamentTitle" aria-modal="true">
    <header>
      <div class="panelTop">
        <h2 id="tournamentTitle">Sett opp turnering</h2>
        <div class="panelActions">
          <button id="tournamentClose" class="closeBtn" aria-label="Lukk">×</button>
        </div>
      </div>
    </header>
    <div class="panelBody">
      <label class="tournamentLabel" for="tournamentName">Turneringsnavn</label>
      <input id="tournamentName" class="tournamentNameInput" placeholder="Turneringsnavn" autocomplete="off"/>
      <div class="tournamentSection">
        <div class="participantsHeader">
          <h3>Deltakere</h3>
          <button type="button" id="tournamentAddParticipant" class="btn btn--primary addParticipantBtn">Legg til deltaker</button>
        </div>
        <ul id="tournamentParticipants" class="participantsList"></ul>
      </div>
    </div>
    <footer>
      <button id="tournamentBack" class="btn btn--ghost">Tilbake</button>
      <button id="tournamentContinue" class="btn btn--primary" disabled>Fortsett</button>
    </footer>
  </div>
</div>

<!-- Tournament Overview Modal -->
<div id="tournamentOverviewMask" class="modalMask fullscreen" style="display:none" aria-hidden="true">
  <div class="modalPanel fullscreenPanel tournamentOverviewPanel" role="dialog" aria-labelledby="tournamentOverviewTitle">
    <header>
      <div class="panelTop">
        <h2 id="tournamentOverviewTitle">Turnering: <span id="tournamentOverviewName"></span></h2>
        <div class="panelActions">
          <button id="tournamentOverviewClose" class="closeBtn" aria-label="Lukk">×</button>
          <button id="tournamentOverviewBack" class="btn btn--ghost">Tilbake</button>
        </div>
      </div>
    </header>
    <div class="panelBody">
      <h3>Kamp-oversikt</h3>
      <div id="tournamentRounds" class="tournamentRounds"></div>
    </div>
    <footer>
      <button id="tournamentOverviewStart" class="btn btn--primary">Start første kamp</button>
    </footer>
  </div>
</div>

<!-- Stats Modal -->
<div id="statsMask" class="modalMask fullscreen" style="display:none" aria-hidden="true">
  <div class="modalPanel fullscreenPanel statsPanel" role="dialog" aria-labelledby="statsTitle">
    <header>
      <div class="panelTop">
        <h2 id="statsTitle">Statistikk</h2>
        <div class="panelActions">
          <button id="statsClose" class="closeBtn" aria-label="Lukk">×</button>
        </div>
      </div>
    </header>
    <div class="panelBody" id="statsPanelBody">
      <!-- Stats content will be rendered here -->
    </div>
  </div>
</div>

<div class="wrap" id="wrap">
  <div class="clickArea left" id="leftArea" aria-label="Legg til poeng venstre"></div>
  <div class="clickArea right" id="rightArea" aria-label="Legg til poeng høyre"></div>

  <div class="side left" id="sideA">
    <div class="name"><div class="chip"><span id="nameA_chip">Spiller A</span></div><div id="setCounterA" class="setCounter">0</div></div>
    <div class="scoreBox"><div class="score" id="scoreA"><span class="digits" id="A_digits"><span class="digit" id="A_tens">0</span><span class="digit" id="A_ones">0</span></span></div></div>
  </div>

  <div class="divider"></div>

  <div class="side right" id="sideB">
    <div class="name"><div class="chip"><span id="nameB_chip">Spiller B</span></div><div id="setCounterB" class="setCounter">0</div></div>
    <div class="scoreBox"><div class="score" id="scoreB"><span class="digits" id="B_digits"><span class="digit" id="B_tens">0</span><span class="digit" id="B_ones">0</span></span></div></div>
  </div>
</div>

<!-- Summary Actions -->
<div class="summaryActions">
  <button id="showSummaryBtn" class="summaryBtn" style="display:none">
    📊 Vis kampsammendrag
  </button>
  <button id="btnFinishMatch" class="summaryBtn finishBtn" style="display:none">
    ✅ Ferdigstill kamp
  </button>
</div>

<!-- Next Set Button (control only) -->
<button id="nextSetBtn" class="summaryBtn" style="display:none">
  ▶ Neste sett
</button>

<!-- Match Summary Modal -->
<div id="summaryMask" class="modalMask" style="display:none">
  <div class="modalBox summaryModal">
    <div class="modalHeader">
      <h2>🏆 Kamp ferdig!</h2>
      <button id="summaryClose" class="closeBtn" aria-label="Lukk">×</button>
    </div>
    
    <div class="modalContent">
      <div id="summaryWinner" class="winnerAnnouncement"></div>
      
      <div class="summaryTable">
  <h3>Kampsammendrag <span id="summaryFormat" class="format-indicator"></span></h3>
  <table>
          <thead>
            <tr>
              <th>Sett</th>
              <th id="sumNameA">Spiller A</th>
              <th id="sumNameB">Spiller B</th>
              <th>Vinner</th>
            </tr>
            <tr id="summaryPlayersRow" style="display:none">
              <th></th>
              <th id="sumPlayersA" class="player-names"></th>
              <th id="sumPlayersB" class="player-names"></th>
              <th></th>
            </tr>
          </thead>
    <tbody id="summaryBody"></tbody>
  </table>
      </div>
</div>

    <div class="modalActions">
      <button id="btnQuickStart" class="btn btn--primary">⚡ Hurtigstart</button>
      <button id="btnNewMatch" class="btn btn--secondary">🆕 Start ny kamp</button>
      <button id="btnCloseSummary" class="btn btn--secondary">Lukk</button>
    </div>
  </div>
</div>

<!-- kebab -->
<div id="kebab" aria-label="Meny" title="Meny" role="button" tabindex="0">
  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><circle cx="12" cy="5" r="2"/><circle cx="12" cy="12" r="2"/><circle cx="12" cy="19" r="2"/></svg>
</div>
<div id="menuPanel" role="menu" aria-label="Hovedmeny"></div>

<!-- share -->
<div id="shareMask" role="dialog" aria-modal="true" aria-labelledby="shareTitle">
  <div id="shareCard">
    <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:.5rem">
      <div id="shareTitle" style="font-weight:700">Del kamp</div>
      <button id="shareClose" class="btn btn--ghost" aria-label="Lukk">✕</button>
    </div>
    
    <!-- Role toggle -->
    <div style="display:flex;align-items:center;justify-content:center;margin-bottom:1rem;gap:0.5rem;flex-wrap:wrap">
      <label style="display:flex;align-items:center;gap:0.25rem;cursor:pointer">
        <input type="radio" name="shareRole" value="spectator" checked style="margin:0">
        <span>👥 Tilskuer</span>
      </label>
      <label style="display:flex;align-items:center;gap:0.25rem;cursor:pointer">
        <input type="radio" name="shareRole" value="cocounter" style="margin:0">
        <span>📱 Medteller</span>
      </label>
    </div>
    
    <div id="qrBox" aria-label="QR-kode"></div>
    <div style="text-align:center;word-break:break-all;margin-top:.25rem;font-size:.85rem;color:#93c5fd" id="shareUrl"></div>
    <div class="shareRow">
      <button id="btnCopy" class="btn btn--primary">Kopier lenke</button>
      <button id="btnOpenSpectator" class="btn btn--primary">Åpne tilskuer</button>
      <button id="btnWebShare" class="btn btn--primary" style="display:none">Del via…</button>
    </div>
  </div>
</div>

<!-- Name modal (used at start + when choosing Edit names) -->
<div id="nameMask">
  <div class="nameCard">
    <h3 style="margin:.2rem 0 1rem 0">Spillernavn</h3>
    
    <!-- Single format -->
    <div id="singleNames" class="nameRow">
      <div class="nameField">
        <label for="nameA">Venstre</label>
        <div class="autocomplete">
          <input id="nameA" placeholder="Spiller A" autocomplete="off"/>
          <button type="button" class="dropdown-btn" onclick="toggleDropdown('nameA')">&#x25BC;</button>
          <div id="nameA-list" class="autocomplete-items"></div>
        </div>
      </div>
      <div class="nameField">
        <label for="nameB">Høyre</label>
        <div class="autocomplete">
          <input id="nameB" placeholder="Spiller B" autocomplete="off"/>
          <button type="button" class="dropdown-btn" onclick="toggleDropdown('nameB')">&#x25BC;</button>
          <div id="nameB-list" class="autocomplete-items"></div>
        </div>
      </div>
    </div>
    
    <!-- Double format -->
    <div id="doubleNames" class="nameRow double" style="display:none">
      <!-- Team A (Left) -->
      <div class="teamWrapper teamA">
        <div class="teamHeader">
          <input id="teamNameA" class="teamNameInput" placeholder="Lag 1" autocomplete="off"/>
          <span class="teamNameLabel">Lag 1</span>
        </div>
        <div class="nameField">
          <label for="nameA1">Spiller 1</label>
          <div class="autocomplete">
            <input id="nameA1" placeholder="Spiller A" autocomplete="off"/>
            <button type="button" class="dropdown-btn" onclick="toggleDropdown('nameA1')">&#x25BC;</button>
            <div id="nameA1-list" class="autocomplete-items"></div>
          </div>
        </div>
        <div class="nameField">
          <label for="nameA2">Spiller 2</label>
          <div class="autocomplete">
            <input id="nameA2" placeholder="Spiller A2" autocomplete="off"/>
            <button type="button" class="dropdown-btn" onclick="toggleDropdown('nameA2')">&#x25BC;</button>
            <div id="nameA2-list" class="autocomplete-items"></div>
          </div>
        </div>
      </div>
      
      <!-- Team B (Right) -->
      <div class="teamWrapper teamB">
        <div class="teamHeader">
          <input id="teamNameB" class="teamNameInput" placeholder="Lag 2" autocomplete="off"/>
          <span class="teamNameLabel">Lag 2</span>
        </div>
        <div class="nameField">
          <label for="nameB1">Spiller 1</label>
          <div class="autocomplete">
            <input id="nameB1" placeholder="Spiller B" autocomplete="off"/>
            <button type="button" class="dropdown-btn" onclick="toggleDropdown('nameB1')">&#x25BC;</button>
            <div id="nameB1-list" class="autocomplete-items"></div>
          </div>
        </div>
        <div class="nameField">
          <label for="nameB2">Spiller 2</label>
          <div class="autocomplete">
            <input id="nameB2" placeholder="Spiller B2" autocomplete="off"/>
            <button type="button" class="dropdown-btn" onclick="toggleDropdown('nameB2')">&#x25BC;</button>
            <div id="nameB2-list" class="autocomplete-items"></div>
          </div>
        </div>
      </div>
    </div>
    
    <div class="modalActions">
      <button id="btnCancelNames" class="btn btn--ghost">Avbryt</button>
      <button id="btnSaveNames" class="btn btn--primary">Lagre</button>
      <button id="btnStart" class="btn btn--primary" style="background:#60a5fa;color:#061a2e">Start kamp</button>
    </div>
  </div>
</div>

<div id="toast"></div>

<!-- Finish Match Modal -->
<div id="finishMatchMask" class="modalMask" style="display:none" aria-hidden="true">
  <div class="modalPanel finishMatchPanel">
    <h3>Ferdigstill kamp</h3>
    <p id="finishMatchHint">Velg hvordan du vil avslutte kampen.</p>
    <p id="finishMatchInfo" class="muted" style="display:none;margin-top:.5rem;"></p>
    <div class="finishActions">
      <button id="finishMatchPlayed" class="btn btn--primary">Kampen er spilt ferdig</button>
      <button id="finishMatchWalkoverA" class="btn btn--secondary">Walkover – lag A</button>
      <button id="finishMatchWalkoverB" class="btn btn--secondary">Walkover – lag B</button>
      <button id="finishMatchCancel" class="btn btn--ghost">Avbryt</button>
    </div>
  </div>
</div>

<script type="module" src="./js/main.js"></script>

  <!-- Confirm Start Modal -->
  <div id="confirmStartMask" class="modalMask" style="display:none" aria-hidden="true">
    <div class="modalBox" role="dialog" aria-labelledby="confirmStartTitle" aria-modal="true">
      <div class="modalHeader">
        <h2 id="confirmStartTitle">Start på nytt?</h2>
        <button id="confirmStartClose" class="closeBtn" aria-label="Lukk">×</button>
      </div>
      <div class="modalContent">
        <p id="confirmStartText">
          Dette vil avslutte og slette pågående kamp. Fortsette?
        </p>
      </div>
      <div class="modalActions">
        <button id="confirmStartCancel" class="btn btn--secondary">Avbryt</button>
        <button id="confirmStartOk" class="btn btn--primary">Fortsett</button>
      </div>
    </div>
  </div>
</body>
</html>













--------------------------------------------------
File End
--------------------------------------------------


info.txt
File type: .txt
Please use ai to generate an ai transition prompt so i can start a new conversation thread. This one is too long. Please summarize the work we have done already, context is important. Preserve the advanced directive also. If you need to create a json to maintain as much context as possible please do so. I cannot lose any important context or things we have decided on. Thank you

--------------------------------------------------
File End
--------------------------------------------------


package.json
File type: .json
{
  "name": "badmintonteller",
  "private": true,
  "version": "0.0.0",
  "scripts": {
    "loc": "node scripts/loc-count.mjs"
  }
}


--------------------------------------------------
File End
--------------------------------------------------


update-autocomplete.js
File type: .js
const fs = require('fs');
const path = require('path');

const files = [
  path.join('js', 'ui', 'namesModal.js'),
  'index.html'
];

// Define the pattern to match with regex - more flexible than exact string matching
const oldPattern = [
  '\\s*var div = document\\.createElement\\("div"\\);',
  '\\s*div\\.innerHTML = "<strong>" \\+ match\\.substr\\(0, val\\.length\\) \\+ "</strong>" \\+ match\\.substr\\(val\\.length\\);',
  '\\s*div\\.innerHTML \\+= "<input type=\\'hidden\\' value=\\'' \\+ match \\+ '\\'>";'
].join('\\s*\\r?\\n\\s*'); // Tolerates both \r\n and \n, plus whitespace variations

const newCode = [
  '      var div = document.createElement("div");',
  '      var strong = document.createElement("strong");',
  '      strong.textContent = match.substr(0, val.length);',
  '      div.appendChild(strong);',
  '      var remainderText = document.createTextNode(match.substr(val.length));',
  '      div.appendChild(remainderText);',
  '      var hiddenInput = document.createElement("input");',
  '      hiddenInput.type = "hidden";',
  '      hiddenInput.value = match;',
  '      div.appendChild(hiddenInput);'
].join('\n');

const regex = new RegExp(oldPattern, 'g');

for (const file of files) {
  const absPath = path.resolve(file);
  let text = fs.readFileSync(absPath, 'utf8');
  
  if (!regex.test(text)) {
    console.error(`pattern not found in ${file}`);
    process.exitCode = 1;
    continue;
  }
  
  // Reset regex for replacement
  regex.lastIndex = 0;
  text = text.replace(regex, newCode);
  fs.writeFileSync(absPath, text);
  console.log(`Updated ${file}`);
}


--------------------------------------------------
File End
--------------------------------------------------


.github\PULL_REQUEST_TEMPLATE.md
File type: .md
## Type
- [ ] refactor
- [ ] feat
- [ ] fix

## Hva
Kort beskrivelse av endringen.

## Hvorfor
Hvorfor var dette nødvendig / hva forenkles eller forbedres?

## Omfang
- Endrede linjer (ca.): <skriv inn kort>
- Lint: OK / feil (skriv hvis noe må følges opp)

## Manuell test (sjekk av)
- [ ] Åpne/lukke relevante modaler (scroll-lås riktig)
- [ ] Navigere "Til start" → "Fortsett …" vises korrekt
- [ ] Start/fortsett kamp/turnering fungerer som før
- [ ] (Andre relevante punkter)

## Notater
- Refactor: ingen nye features / uendret oppførsel
- Feat: kort brukerhistorie og hva som er nytt



--------------------------------------------------
File End
--------------------------------------------------


.vscode\settings.json
File type: .json
{
    "liveServer.settings.port": 5501
}

--------------------------------------------------
File End
--------------------------------------------------


css\base.css
File type: .css
:root{--gap:clamp(12px,3vw,36px);--divider:2px;--accent:#60a5fa;--minus:#ef4444}
*{box-sizing:border-box;-webkit-tap-highlight-color:transparent}
html,body{height:100%}
body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;background:#0b1224;color:#fff;display:flex;flex-direction:column;max-width:100vw;overflow-x:hidden;user-select:none}
body.no-scroll{overflow-y:hidden}
body.splash-open{overflow:hidden}
/* Base button (samler dupliserte egenskaper, ingen visuell endring) */
.btn{
  display:inline-flex; align-items:center; justify-content:center;
  gap:.5rem;
  font: inherit;
  padding:.6rem .9rem;
  border-radius:.6rem;
  border:1px solid transparent;
  cursor:pointer;
  transition:transform .12s ease, box-shadow .12s ease, background-color .12s ease, border-color .12s ease;
}
.btn--primary{ background:#243147; border-color:#32425f; color:#e5e7eb; }
.btn--primary:hover{ transform:translateY(-1px); box-shadow:0 6px 16px rgba(0,0,0,.25); }
.btn--ghost{ background:transparent; border-color:#32425f; color:#e5e7eb; }
.btn--ghost:hover{ background:rgba(255,255,255,0.1); }
.btn--secondary{ background:#374151; color:#e2e8f0; }
.btn--secondary:hover{ background:#4b5563; transform:translateY(-1px); }
.btn--danger{ background:#3a1212; border-color:#5a1b1b; }
.btn--icon{ padding:.4rem; min-width:2.25rem; min-height:2.25rem; }

.button{font:inherit;border:0;border-radius:.5rem;padding:.45rem .7rem;cursor:pointer;background:#243147;color:#e5e7eb;border:1px solid #32425f}
.button.ghost{background:transparent}
#toast{position:fixed;bottom:10px;left:50%;transform:translateX(-50%);background:#111827;border:1px solid #233454;color:#e5e7eb;padding:.45rem .7rem;border-radius:.5rem;z-index:70;display:none}

--------------------------------------------------
File End
--------------------------------------------------


css\layout.css
File type: .css
.wrap{flex:1 1 auto;min-height:100vh;display:grid;grid-template-columns:1fr var(--divider) 1fr;column-gap:var(--gap);padding:var(--gap);align-items:stretch;overflow:hidden;position:relative}
.divider{width:var(--divider);background:#1e293b;z-index:2}
.side{position:relative;background:#0f172a;border-radius:.8rem;padding:clamp(8px,1.8vw,16px);display:flex;flex-direction:column;align-items:center;justify-content:flex-start;overflow:hidden;transition:transform 1s ease;z-index:1}
.wrap.swap-go .left{transform:translateX(calc(100% + var(--gap) + var(--divider)))}
.wrap.swap-go .right{transform:translateX(calc(-100% - var(--gap) - var(--divider)))}
.no-trans .side{transition:none!important}
.name{min-height:clamp(36px,6vh,56px);display:flex;align-items:center;justify-content:center;width:100%;margin:.6rem 0 .25rem 0;position:relative}
.name .chip{background:#111827;border:1px solid #0008;border-radius:.5rem;min-width:12ch;max-width:22ch;padding:.35rem .8rem}
.name .chip span{display:block;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
.setCounter{position:absolute;right:-.35rem;top:50%;transform:translate(0,-50%);background:var(--accent);color:#061a2e;font-weight:900;border-radius:999px;padding:.18rem .62rem;min-width:2rem;text-align:center;box-shadow:0 0 10px rgba(96,165,250,.45),0 0 24px rgba(59,130,246,.35);display:none}
@media (max-width:520px){.setCounter{right:-.15rem}}
.scoreBox{flex:1 1 auto;width:100%;min-height:0;display:flex;align-items:center;justify-content:center;overflow:visible}
.score{width:100%;display:flex;justify-content:center;align-items:center;text-align:center;font-weight:900;line-height:.92;cursor:pointer;white-space:nowrap;overflow:visible;font-variant-numeric:tabular-nums;will-change:transform,text-shadow;padding:0 2vw;transition:color .6s,text-shadow .6s;font-size:0}
.digits{display:flex;gap:.08em;align-items:baseline;max-width:100%;overflow:visible}
.digit{display:inline-block;width:1ch;text-align:center}
.digit.ghost{visibility:hidden}
#A_digits.pop{animation:glowBurst .55s ease-out 1;isolation:isolate;transform-origin:center center;contain:layout style paint}
#B_digits.pop{animation:glowBurst .55s ease-out 1;isolation:isolate;transform-origin:center center;contain:layout style paint}
#A_digits.popMinus{animation:minusBurst .55s ease-out 1;isolation:isolate;transform-origin:center center;contain:layout style paint}
#B_digits.popMinus{animation:minusBurst .55s ease-out 1;isolation:isolate;transform-origin:center center;contain:layout style paint}
@keyframes glowBurst{0%{text-shadow:0 0 0 rgba(96,165,250,0);transform:scale3d(1,1,1)}20%{text-shadow:0 0 30px rgba(96,165,250,.95),0 0 70px rgba(59,130,246,.8),0 0 110px rgba(37,99,235,.7);transform:scale3d(1.08,1.08,1)}60%{text-shadow:0 0 20px rgba(96,165,250,.55),0 0 50px rgba(59,130,246,.45);transform:scale3d(1.03,1.03,1)}100%{text-shadow:0 0 0 rgba(96,165,250,0);transform:scale3d(1,1,1)}}
@keyframes minusBurst{0%{text-shadow:0 0 0 rgba(239,68,68,0);transform:scale3d(1,1,1)}20%{text-shadow:0 0 30px rgba(239,68,68,.95),0 0 70px rgba(239,68,68,.7),0 0 110px rgba(185,28,28,.6);transform:scale3d(0.96,0.96,1)}60%{text-shadow:0 0 20px rgba(239,68,68,.5),0 0 50px rgba(185,28,28,.4);transform:scale3d(0.985,0.985,1)}100%{text-shadow:0 0 0 rgba(239,68,68,0);transform:scale3d(1,1,1)}}
.winner,.winnerName{color:#ffd700!important;animation:goldPulse 3s ease-in-out infinite}
@keyframes goldPulse{0%{text-shadow:0 0 3px rgba(255,215,0,.25),0 0 6px rgba(255,220,50,.2)}50%{text-shadow:0 0 8px rgba(255,215,0,.5),0 0 16px rgba(255,220,50,.4)}100%{text-shadow:0 0 3px rgba(255,215,0,.25),0 0 6px rgba(255,220,50,.2)}}
#sets{padding:.35rem 1rem .2rem;text-align:center;font-size:1rem;display:none}
.clickArea{position:absolute;top:0;bottom:0;width:calc(50% - 24px);z-index:3;background:transparent;pointer-events:none}
.areas-active .clickArea{pointer-events:auto;touch-action:pan-y}
.clickArea.left{left:0}
.clickArea.right{right:0}
#kebab{position:fixed;top:10px;right:10px;z-index:50;background:#0f172a;border:1px solid #233454;border-radius:.6rem;padding:.35rem .55rem;cursor:pointer;display:none}
#kebab svg{display:block;width:20px;height:20px}
#kebab.pulse{box-shadow:0 0 0 0 rgba(96,165,250,.55);animation:kebabPulse 1.8s ease-out 2}
@keyframes kebabPulse{0%{box-shadow:0 0 0 0 rgba(96,165,250,.55)}70%{box-shadow:0 0 0 14px rgba(96,165,250,0)}100%{box-shadow:0 0 0 0 rgba(96,165,250,0)}}
#menuPanel{position:fixed;top:46px;right:10px;background:#0b1224;border:1px solid #122042;border-radius:.6rem;box-shadow:0 8px 28px rgba(0,0,0,.45);z-index:51;display:none;min-width:240px}
.menuItem{display:flex;align-items:center;gap:.6rem;padding:.55rem .7rem;cursor:pointer;color:#e5e7eb}
.menuItem:hover{background:#0f1a33}
.menuHR{height:1px;background:#1e293b;margin:.25rem 0}

--------------------------------------------------
File End
--------------------------------------------------


css\modal.css
File type: .css
#nameMask{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.6);z-index:65}
.nameCard{background:#0b1224;border:1px solid #122042;border-radius:1rem;padding:1rem 1.2rem;width:min(560px,92vw);max-width:calc(100vw - 2rem)}
.nameCard.double{width:min(720px,95vw)}
.nameRow{display:grid;grid-template-columns:1fr 1fr;gap:.8rem}
.nameRow.double{grid-template-columns:1fr 1fr;gap:1.5rem}
.teamWrapper{display:flex;flex-direction:column;gap:.8rem}
.teamHeader{position:relative;margin-bottom:.5rem}
.teamNameInput{font:inherit;background:transparent;color:#e2e8f0;border:none;border-bottom:2px solid #60a5fa;border-radius:0;padding:.3rem 0;width:100%;font-size:1.1rem;font-weight:600;transition:all .2s}
.teamNameInput:focus{outline:none;border-bottom-color:#93c5fd;background:rgba(96,165,250,0.1)}
.teamNameInput::placeholder{color:#94a3b8;font-weight:normal}
.teamNameLabel{position:absolute;top:.3rem;left:0;color:#94a3b8;font-size:1.1rem;font-weight:600;pointer-events:none;transition:opacity .2s}
.teamNameInput:focus + .teamNameLabel{opacity:0}
.teamNameInput:not(:placeholder-shown) + .teamNameLabel{opacity:0}
.nameField{display:flex;flex-direction:column;gap:.3rem;min-width:0}
.nameField label{font-size:.85rem;color:#93c5fd}
.nameField input{font:inherit;background:#111827;color:#e5e7eb;border:1px solid #233454;border-radius:.6rem;padding:.5rem .7rem;width:100%;box-sizing:border-box}
.autocomplete{position:relative;display:block;width:100%}
.autocomplete input{padding-right:2.5rem;width:100%;box-sizing:border-box}
.autocomplete input.no-dropdown{padding-right:.7rem}
.dropdown-btn{position:absolute;right:.5rem;top:50%;transform:translateY(-50%);background:none;border:none;color:#94a3b8;cursor:pointer;font-size:.8rem;padding:.2rem;border-radius:.2rem;transition:color .2s}
.dropdown-btn:hover{color:#e2e8f0;background:rgba(255,255,255,.1)}
.dropdown-btn.hidden{display:none}
.autocomplete-items{position:absolute;top:calc(100% - 1px);left:0;right:0;border:1px solid #233454;border-top:none;border-radius:0 0 .6rem .6rem;background:#111827;box-shadow:0 8px 24px rgba(0,0,0,.35);overflow:hidden;z-index:1000;max-height:200px;margin:0}
.autocomplete-items div{padding:.6rem .8rem;border-bottom:1px solid #233454;cursor:pointer;transition:background .2s}
.autocomplete-items div:hover{background:#2d3b57}
.autocomplete-items div:last-child{border-bottom:0}
.autocomplete-active{background-color:#60a5fa!important;color:#061a2e!important}
.modalMask{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.8);display:flex;align-items:center;justify-content:center;z-index:1000}
.modalBox{background:#0f172a;border-radius:1rem;padding:1.5rem;max-width:90vw;max-height:90vh;overflow-y:auto;box-shadow:0 25px 50px -12px rgba(0,0,0,.5);border:1px solid #1e293b}
.modalHeader{display:flex;justify-content:space-between;align-items:center;margin-bottom:1rem;padding-bottom:.5rem;border-bottom:1px solid #1e293b}
.modalHeader h2{margin:0;color:#e2e8f0;font-size:1.5rem}
.closeBtn{background:none;border:none;color:#94a3b8;font-size:1.5rem;cursor:pointer;padding:.25rem;border-radius:.25rem;transition:color .2s}
.closeBtn:hover{color:#e2e8f0;background:rgba(255,255,255,.1)}
.modalContent{margin-bottom:1.5rem}
.modalActions{display:flex;gap:.75rem;justify-content:flex-end}
/* btnPrimary and btnSecondary moved to base.css as btn--primary and btn--secondary */
.button.warning{background:#dc2626;color:#ffffff}
.button.warning:hover{background:#ef4444;transform:translateY(-1px)}
.summaryModal{max-width:90vw;max-height:90vh;overflow-y:auto}
.winnerAnnouncement{text-align:center;font-size:1.2rem;font-weight:700;color:var(--accent);margin-bottom:1.5rem;padding:1rem;background:rgba(96,165,250,0.1);border-radius:.5rem;border:1px solid rgba(96,165,250,0.3)}
.summaryTable{margin:1rem 0}
.summaryTable h3{margin:0 0 .8rem 0;font-size:1.1rem;color:#e2e8f0}
.format-indicator{font-size:.8rem;color:#94a3b8;font-weight:normal;margin-left:.5rem}
.summaryTable table{width:100%;border-collapse:collapse;background:rgba(15,23,42,0.5);border-radius:.5rem;overflow:hidden}
.summaryTable th,.summaryTable td{padding:.6rem .8rem;text-align:center;border-bottom:1px solid rgba(30,41,59,0.5)}
.summaryTable th{background:rgba(30,41,59,0.8);font-weight:600;color:#cbd5e1}
.summaryTable th.player-names{font-size:.8rem;font-weight:normal;color:#94a3b8;padding:.3rem .8rem}
.summaryTable td{color:#e2e8f0}
.summaryTable tbody tr:last-child td{border-bottom:none}
.summaryTable tbody tr:hover{background:rgba(30,41,59,0.3)}
.summaryBtn{position:fixed;bottom:2rem;left:50%;transform:translateX(-50%);background:var(--accent);color:#061a2e;border:none;border-radius:2rem;padding:1rem 2rem;font-size:1.1rem;font-weight:700;cursor:pointer;box-shadow:0 8px 25px rgba(96,165,250,0.4);transition:all .3s ease;z-index:10;animation:pulse 2s infinite}
.summaryBtn:hover{background:#60a5fa;transform:translateX(-50%) translateY(-2px);box-shadow:0 12px 35px rgba(96,165,250,0.6)}
.summaryBtn:active{transform:translateX(-50%) translateY(0)}
@keyframes pulse{0%{box-shadow:0 8px 25px rgba(96,165,250,0.4)}50%{box-shadow:0 8px 25px rgba(96,165,250,0.8)}100%{box-shadow:0 8px 25px rgba(96,165,250,0.4)}}

.summaryActions{position:fixed;bottom:2.2rem;left:50%;transform:translateX(-50%);display:flex;gap:1rem;z-index:20}
.summaryActions .summaryBtn{min-width:12rem;position:static;transform:none;box-shadow:0 10px 25px rgba(96,165,250,0.35);animation:none}
.summaryActions .finishBtn{background:linear-gradient(135deg, #ef4444, #f97316)}
.summaryActions .finishBtn:hover{background:linear-gradient(135deg, #f97316, #ef4444)}
.tournamentModal{width:min(640px,92vw)}
.tournamentLabel{display:block;margin-bottom:.4rem;font-size:.9rem;color:#93c5fd}
.tournamentNameInput{font:inherit;background:#111827;color:#e5e7eb;border:1px solid #233454;border-radius:.6rem;padding:.6rem .75rem;width:100%;box-sizing:border-box}
.tournamentNameInput:focus{outline:none;border-color:#60a5fa;box-shadow:0 0 0 1px rgba(96,165,250,0.35)}
.tournamentSection{margin-top:1.5rem}
.participantsHeader{display:flex;align-items:center;justify-content:space-between;gap:1rem}
.participantsHeader h3{margin:0;font-size:1.05rem;color:#e2e8f0}
.addParticipantBtn{background:#1e293b;color:#e2e8f0;border:none;font-weight:600}
.addParticipantBtn:hover{background:#2d3b57}
.participantsList{list-style:none;margin:1rem 0 0 0;padding:0;display:flex;flex-direction:column;gap:.75rem}
.participantRow{display:flex;align-items:center;gap:.75rem}
.participantInput{flex:1;font:inherit;background:#111827;color:#e5e7eb;border:1px solid #233454;border-radius:.6rem;padding:.55rem .75rem}
.participantInput:focus{outline:none;border-color:#60a5fa;box-shadow:0 0 0 1px rgba(96,165,250,0.35)}
.participantRow .autocomplete{flex:1}
.participantRow .autocomplete input{padding-right:2.5rem}
.participantRow .autocomplete input.no-dropdown{padding-right:.75rem}
.participantRow .dropdown-btn{position:absolute;right:.5rem;top:50%;transform:translateY(-50%);background:none;border:none;color:#94a3b8;cursor:pointer;font-size:.8rem;padding:.2rem;border-radius:.2rem;transition:color .2s}
.participantRow .dropdown-btn:hover{color:#e2e8f0;background:rgba(255,255,255,.1)}
.participantRow .dropdown-btn.hidden{display:none}
.participantRemove{background:none;border:1px solid #334155;color:#cbd5f5;font-size:.85rem}
.participantRemove:hover{background:rgba(96,165,250,0.15);border-color:#60a5fa;color:#e2e8f0}

/* Tournament Overview Modal */
.tournamentOverviewModal{width:min(720px,92vw)}
.tournamentOverviewContent{margin:1rem 0}
.tournamentOverviewContent h3{margin:0 0 1rem 0;font-size:1.2rem;color:#e2e8f0;border-bottom:1px solid #1e293b;padding-bottom:.5rem}
.tournamentRounds{margin-top:1rem}
.tournamentRound{margin-bottom:1.5rem}
.tournamentRound h4{margin:0 0 .75rem 0;font-size:1.1rem;color:#e2e8f0;border-bottom:1px solid #334155;padding-bottom:.5rem}
.tournamentMatches{list-style:none;margin:0;padding:0}
.tournamentMatch{
  padding: 0.85rem 1rem;
  background: rgba(15,23,42,0.3);
  border-radius: 0.75rem;
  margin-bottom: 0.75rem;
  color: #cbd5e1;
  font-size: 0.95rem;
  display: grid;
  grid-template-columns: 6.5rem minmax(0, 1fr) 8rem;
  column-gap: 1.75rem;
  align-items: center;
}
.tournamentMatch:last-child{margin-bottom:0}
.tournamentMatchInfo{flex:1}
.tournamentMatch .actions {
  justify-self: end;
  white-space: nowrap;
}

.tournamentMatchBtn{
  background: #60a5fa;
  color: #061a2e;
  border: none;
  border-radius: 0.5rem;
  padding: 0.5rem 1rem;
  font-size: 0.85rem;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
}
.tournamentMatchBtn:hover{background:#93c5fd;transform:translateY(-1px)}
.tournamentMatchBtn:active{transform:translateY(0)}
.tournamentMatchBtn.disabled{background:#6b7280;color:#9ca3af;cursor:not-allowed;transform:none}
.tournamentMatchBtn.disabled:hover{background:#6b7280;transform:none}
.matchStatus{font-size:.8rem;color:#94a3b8;font-style:italic;margin-top:.2rem}

.tournamentMatch.just-finished{box-shadow:0 0 0 2px #60a5fa;background:rgba(96,165,250,0.18)}

/* Tournament Match Card Layout */
.matchLabel {
  font-size: 0.85rem;
  color: #94a3b8;
  font-weight: 600;
  display: flex;
  align-items: center;
}



.playerCardsContainer {
  display: flex;
  align-items: stretch;
  gap: 0.75rem;
  flex-wrap: wrap;
  justify-content: center;
}


.match-vs {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 0.75rem;
  margin: 0 0.5rem;
  flex-shrink: 0;
}

.match-status {
  padding: 0.25rem 0.5rem;
  border-radius: 0.5rem;
  font-size: 0.7rem;
  font-weight: 600;
  text-align: center;
  white-space: nowrap;
}

.match-status.status-waiting {
  background: rgba(148, 163, 184, 0.3);
  color: #94a3b8;
}

.match-status.status-ongoing {
  background: #60a5fa;
  color: #061a2e;
}

.match-status.status-finished {
  background: #fbbf24;
  color: #061a2e;
}

.vs-chip {
  background: rgba(15, 23, 42, 0.8);
  border: 1px solid #60a5fa;
  border-radius: 50%;
  width: 2.5rem;
  height: 2.5rem;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 0.8rem;
  font-weight: 600;
  color: #e2e8f0;
}

.player-card {
  flex: 1;
  min-width: 9rem;
  min-height: 7rem;
  background: rgba(15, 23, 42, 0.6);
  border: 1px solid rgba(148, 163, 184, 0.2);
  border-radius: 0.75rem;
  padding: 1rem 0.75rem;
  display: flex;
  flex-direction: column;
  position: relative;
  transition: all 0.3s ease;
}

.card-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: 1rem;
  gap: 0.5rem;
}

.player-name {
  font-size: 0.85rem;
  font-weight: 600;
  color: #e2e8f0;
  white-space: normal;
  word-break: break-word;
  line-height: 1.2;
  flex: 1;
}

.set-badge {
  background: #60a5fa;
  color: #061a2e;
  border-radius: 0.75rem;
  padding: 0.15rem 0.35rem;
  font-size: 0.65rem;
  font-weight: 700;
  min-width: 1.25rem;
  text-align: center;
  align-self: flex-start;
  margin-top: -0.1rem;
}

.score-slot {
  font-size: 2rem;
  font-weight: 700;
  color: #e2e8f0;
  line-height: 1;
  text-align: center;
  transition: opacity 0.3s ease;
}

.gold-text {
  color: #fbbf24 !important;
}

.match-summary {
  min-height: 1.5rem;
  padding: 0.5rem 0;
  margin-top: 0.75rem;
  border-top: 1px solid rgba(148, 163, 184, 0.2);
  font-size: 0.8rem;
  color: #e2e8f0;
  text-align: center;
  line-height: 1.3;
  transition: opacity 0.3s ease;
  word-break: break-word;
}


/* Finish Match Modal */
.finishMatchPanel{max-width:400px;text-align:center}
.finishActions{display:flex;flex-direction:column;gap:.5rem;margin-top:1rem}
.finishActions button{margin-top:.5rem}
.muted{color:#94a3b8;font-size:.9rem}

/* Fullscreen Panel Styles */
.modalMask.fullscreen {
  display: flex;
  align-items: center;
  justify-content: center;
  padding: clamp(1rem, 4vh, 2.5rem);
}

.modalPanel.fullscreenPanel {
  width: min(900px, 92vw);
  height: min(90vh, 880px);
  max-height: 90vh;
  display: flex;
  flex-direction: column;
  background: #0f172a;
  border-radius: 1.2rem;
  border: 1px solid rgba(148, 163, 184, 0.25);
  box-shadow: 0 35px 80px rgba(15, 23, 42, 0.6);
  overflow: hidden;
}

.modalPanel.fullscreenPanel .panelBody {
  flex: 1 1 auto;
  overflow-y: auto;
  padding: 1.2rem 1.5rem 1.8rem;
}

.modalPanel.fullscreenPanel .panelBody::-webkit-scrollbar {
  width: 0.55rem;
}

.modalPanel.fullscreenPanel header {
  position: sticky;
  top: 0;
  z-index: 2;
  background: inherit;
  padding: 1.2rem 1.5rem 0;
}

.modalPanel.fullscreenPanel footer {
  padding: 1rem 1.5rem;
  border-top: 1px solid rgba(148, 163, 184, 0.18);
  display: flex;
  gap: 0.75rem;
  justify-content: flex-end;
}

.panelTop {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 1rem;
}

.panelActions {
  display: flex;
  gap: 0.5rem;
  align-items: center;
}



--------------------------------------------------
File End
--------------------------------------------------


css\share.css
File type: .css
#shareMask{position:fixed;inset:0;background:rgba(0,0,0,.5);display:none;align-items:center;justify-content:center;z-index:60}
#shareCard{background:#0b1224;border:1px solid #122042;border-radius:.8rem;padding:1rem;max-width:92vw;width:min(560px,92vw)}
#qrBox{display:block;margin:.5rem auto;background:#0f172a;border:1px solid #233454;border-radius:.4rem;padding:.5rem;min-width:240px;text-align:center}
.shareRow{display:flex;gap:.5rem;flex-wrap:wrap;justify-content:center;margin-top:.5rem}
#shareUrl{text-align:center;word-break:break-all;margin-top:.25rem;font-size:.85rem;color:#93c5fd}

--------------------------------------------------
File End
--------------------------------------------------


css\splash.css
File type: .css
#splashMask{position:fixed;inset:0;display:none;align-items:center;justify-content:center;padding:clamp(20px,5vw,60px);background:radial-gradient(circle at 20% 20%,rgba(37,99,235,.35) 0%,rgba(11,17,35,.92) 45%,rgba(5,9,20,.98) 100%);backdrop-filter:blur(6px);z-index:80}
#splashMask::before{content:"";position:absolute;inset:0;background:linear-gradient(135deg,rgba(96,165,250,.35),rgba(14,165,233,0));pointer-events:none;mix-blend-mode:screen;opacity:.8}
#splashMask.show{display:flex}
.splashMask{position:relative}
.splashPanel{position:relative;max-width:520px;width:100%;background:rgba(8,14,30,.9);border:1px solid rgba(59,130,246,.35);border-radius:1.1rem;padding:clamp(26px,4vw,52px);box-shadow:0 25px 60px rgba(15,23,42,.65),0 0 45px rgba(59,130,246,.35);text-align:center;z-index:1;overflow:hidden}
.splashPanel::before{content:"";position:absolute;inset:-30%;background:radial-gradient(circle at center,rgba(96,165,250,.28),rgba(96,165,250,0));opacity:.9;z-index:-1;animation:splashGlow 6s ease-in-out infinite}
.splashTitle{font-size:clamp(1.8rem,4vw,2.6rem);margin:0 0 .7em;color:#e2e8f0;text-shadow:0 0 18px rgba(96,165,250,.45)}
.splashLead{margin:-.3em 0 1.8em;font-size:1rem;color:rgba(226,232,240,.75)}
.splashGroup{display:flex;gap:.75rem;justify-content:center;margin-bottom:1.5rem;flex-wrap:wrap}
.splashToggle{flex:1 1 calc(50% - .75rem);min-width:140px;padding:.85rem 1.2rem;border-radius:.9rem;border:1px solid rgba(59,130,246,.35);background:rgba(17,24,39,.85);color:#dbeafe;font-weight:650;letter-spacing:.02em;text-transform:uppercase;font-size:.95rem;cursor:pointer;transition:all .25s ease;position:relative;isolation:isolate}
.splashToggle::after{content:"";position:absolute;inset:-2px;border-radius:inherit;background:linear-gradient(135deg,rgba(96,165,250,.55),rgba(59,130,246,0));opacity:0;transition:opacity .25s ease;z-index:-1}
.splashToggle.active{background:rgba(30,64,175,.95);border-color:rgba(96,165,250,.9);box-shadow:0 10px 30px rgba(37,99,235,.45),0 0 25px rgba(96,165,250,.55)}
.splashToggle.active::after{opacity:1}
.splashToggle:focus-visible{outline:2px solid rgba(96,165,250,.9);outline-offset:3px}
.splashStart{width:100%;max-width:260px;margin:0 auto;padding:1rem 2.6rem;border-radius:2rem;border:none;background:linear-gradient(135deg,rgba(96,165,250,.95),rgba(14,165,233,.9));color:#041225;font-weight:800;font-size:1.05rem;letter-spacing:.04em;cursor:pointer;box-shadow:0 18px 45px rgba(37,99,235,.55);transition:transform .25s ease,box-shadow .25s ease}
.splashStart:hover{transform:translateY(-2px);box-shadow:0 22px 55px rgba(59,130,246,.6)}
.splashStart:active{transform:translateY(0);box-shadow:0 12px 30px rgba(59,130,246,.5)}
@keyframes splashGlow{0%{transform:rotate(0deg)}50%{transform:rotate(8deg)}100%{transform:rotate(0deg)}}
@media (max-width:520px){.splashToggle{min-width:120px;padding:.8rem 1rem;font-size:.9rem}}
.splashContinue{width:100%;max-width:260px;margin:1rem auto 0 auto;padding:.85rem 2.4rem;border-radius:2rem;border:1px solid rgba(148,163,184,.6);background:rgba(15,23,42,.85);color:#e2e8f0;font-weight:650;font-size:.95rem;letter-spacing:.02em;cursor:pointer;transition:transform .25s ease,box-shadow .25s ease,background .25s ease}
.splashContinue:hover{transform:translateY(-1px);box-shadow:0 12px 30px rgba(30,41,59,.45);background:rgba(30,41,59,.92)}
.splashContinue:active{transform:translateY(0);box-shadow:0 8px 20px rgba(30,41,59,.4)}


--------------------------------------------------
File End
--------------------------------------------------


css\stats.css
File type: .css
.summary{margin:.8rem clamp(12px,3vw,36px) 0;background:#0b1224;border:1px solid #0b1224;border-radius:.8rem;padding:1rem}
.stats{display:grid;grid-template-columns:repeat(auto-fit,minmax(160px,1fr));gap:.6rem;margin-bottom:1rem}
.stat{background:#0f1a33;border:1px solid #122042;border-radius:.6rem;padding:.6rem .7rem;text-align:center}
.stat .muted{opacity:.85;font-size:.8rem}
.leader{display:grid;grid-template-columns:1fr auto;gap:.35rem .6rem}
#statsHost{position:fixed;top:0;left:0;width:100%;height:100%;background:#0b1224;overflow-y:auto;z-index:50;padding:1rem}
body.stats-mode #kebab{z-index:1001}
body.stats-mode #menuPanel{z-index:1002}
#statsHost table{width:100%;border-collapse:collapse;margin-top:1rem}
#statsHost th,#statsHost td{padding:.5rem;text-align:left;border-bottom:1px solid #1e293b}
#statsHost th{background:#1e293b;font-weight:600}
#statsHost tr:hover{background:rgba(30,41,59,0.3)}

--------------------------------------------------
File End
--------------------------------------------------


css\tournament.css
File type: .css
/* Tournament Overview Table Styles */
.tournament-table {
  width: 100%;
  border-collapse: collapse;
  background: rgba(15, 23, 42, 0.3);
  border-radius: 0.75rem;
  overflow: hidden;
  margin-top: 1rem;
}

.tournament-table th {
  background: rgba(30, 41, 59, 0.8);
  color: #cbd5e1;
  font-weight: 600;
  font-size: 0.9rem;
  padding: 0.75rem 1rem;
  text-align: left;
  border-bottom: 1px solid rgba(148, 163, 184, 0.2);
}

.tournament-table th:first-child {
  width: 4rem;
  text-align: center;
}

.tournament-table th:nth-child(2) {
  width: auto;
}

.tournament-table th:nth-child(3) {
  width: 12rem;
  text-align: center;
}

.tournament-table th:last-child {
  width: 8rem;
  text-align: center;
}

.tournament-table td {
  padding: 0.75rem 1rem;
  border-bottom: 1px solid rgba(148, 163, 184, 0.1);
  vertical-align: middle;
}

.tournament-table tbody tr:hover {
  background: rgba(30, 41, 59, 0.2);
}

.tournament-table tbody tr:last-child td {
  border-bottom: none;
}

/* Match number column */
.match-number {
  text-align: center;
  font-weight: 600;
  color: #94a3b8;
  font-size: 0.85rem;
}

/* Players column */
.match-players {
  font-size: 0.9rem;
  color: #e2e8f0;
  line-height: 1.3;
}

.match-players .player-name {
  font-weight: 600;
}

.match-players .vs {
  color: #94a3b8;
  margin: 0 0.5rem;
  font-weight: normal;
}

/* Status column */
.match-status-cell {
  text-align: center;
  font-size: 0.85rem;
}

.status-waiting {
  color: #94a3b8;
  font-style: italic;
}

.status-ongoing {
  color: #60a5fa;
  font-weight: 600;
}

.status-finished {
  color: #cbd5e1;
  font-weight: 600;
}

/* Live set indicator with pulsing effect */
.live-set {
  display: inline-block;
  font-size: 1.1rem;
  font-weight: 700;
  color: #60a5fa;
  animation: pulse-live 1.5s ease-in-out infinite;
}

@keyframes pulse-live {
  0%, 100% {
    transform: scale(1);
    opacity: 1;
  }
  50% {
    transform: scale(1.1);
    opacity: 0.8;
  }
}

/* Set scores display */
.set-scores {
  display: flex;
  gap: 0.5rem;
  justify-content: center;
  align-items: center;
  flex-wrap: wrap;
}

.set-score {
  background: rgba(30, 41, 59, 0.6);
  border: 1px solid rgba(148, 163, 184, 0.3);
  border-radius: 0.4rem;
  padding: 0.2rem 0.4rem;
  font-size: 0.75rem;
  font-weight: 600;
  color: #e2e8f0;
  min-width: 2rem;
  text-align: center;
}

.set-score.current {
  background: #60a5fa;
  color: #061a2e;
  border-color: #60a5fa;
}

/* Winner styling */
.winner-name {
  color: #fbbf24 !important;
  font-weight: 700;
}

.set-score.winner-scores {
  color: #fbbf24;
  font-weight: 700;
}

/* Action column */
.match-action {
  text-align: center;
}

.tournament-table-btn {
  background: #60a5fa;
  color: #061a2e;
  border: none;
  border-radius: 0.5rem;
  padding: 0.5rem 1rem;
  font-size: 0.8rem;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
  white-space: nowrap;
}

.tournament-table-btn:hover {
  background: #93c5fd;
  transform: translateY(-1px);
}

.tournament-table-btn:active {
  transform: translateY(0);
}

.tournament-table-btn.disabled {
  background: #6b7280;
  color: #9ca3af;
  cursor: not-allowed;
  transform: none;
}

.tournament-table-btn.disabled:hover {
  background: #6b7280;
  transform: none;
}

/* Walkover styling */
.walkover-info {
  font-size: 0.7rem;
  color: #94a3b8;
  margin-top: 0.2rem;
  font-style: italic;
}

/* Round headers */
.tournament-round-header {
  margin: 1.5rem 0 0.75rem 0;
  font-size: 1.1rem;
  color: #e2e8f0;
  border-bottom: 1px solid #334155;
  padding-bottom: 0.5rem;
  font-weight: 600;
}

.tournament-round-header:first-child {
  margin-top: 0;
}



--------------------------------------------------
File End
--------------------------------------------------


docs\ARCHITECTURE.md
File type: .md
# Arkitekturprinsipper for BadmintonTeller

Dette dokumentet definerer de grunnleggende prinsippene for hvordan kode skal skrives og struktureres i BadmintonTeller-prosjektet.

---

## 🎯 Kjerneprinsipp: Eleganse over kompleksitet

**"Velg alltid den enkleste løsningen som løser problemet fullstendig."**

### ✅ Foretrekk:
- **Enkle, forståelige løsninger** over smarte, komplekse hacks
- **Direkte årsak-virkning** over indirekte koblinger
- **Få moving parts** over mange koordinerte komponenter
- **Tydelig kontrollflyt** over implisitt timing og state

### ❌ Unngå:
- **Symptombehandling** - fiks rotårsaken, ikke symptomene
- **Race condition-patches** - redesign for å eliminere racet
- **Timing-avhengig kode** - bruk promises/callbacks i stedet
- **Cross-module koordinering** - reduser avhengigheter

---

## 🏗️ Arkitekturprinsipper

### 1. **Separation of Concerns**
```javascript
// ✅ Bra: Hver modul har ett ansvar
firebase.js    // Kun Firebase-kommunikasjon
matchView.js   // Kun UI-logikk for kamper
state.js       // Kun state-håndtering

// ❌ Dårlig: Blandet ansvar
matchView.js   // UI + Firebase + state + validering
```

### 2. **Fail Fast & Graceful Degradation**
```javascript
// ✅ Bra: Håndter feil eksplisitt
pushResult
  .then(() => reEnableReads())
  .catch(() => reEnableReads()); // Fortsett selv ved feil

// ❌ Dårlig: Anta at alt går bra
setTimeout(reEnableReads, 200); // Hva hvis push feiler?
```

### 3. **Predictable State Flow**
```javascript
// ✅ Bra: Tydelig rekkefølge
unbindReads() → resetState() → pushState() → bindReads()

// ❌ Dårlig: Timing-avhengig suppression
suppressReads(1000); resetState(); pushState();
```

### 4. **Single Source of Truth**
- **Firebase** er master for delt state
- **Lokal state** er kun for UI-optimering
- **Ved konflikt:** Firebase vinner alltid

---

## 🔧 Praktiske retningslinjer

### **Race Conditions**
```javascript
// ✅ Bra: Disable → Modify → Enable
unbindListener();
modifyState();
pushToServer().then(() => bindListener());

// ❌ Dårlig: Suppression-flags
if (suppressUntil > now) return; // Komplekst og feilpront
```

### **Error Handling**
```javascript
// ✅ Bra: Eksplisitt error-håndtering
try {
  await riskyOperation();
} catch (error) {
  console.warn('Operation failed, continuing:', error);
  fallbackOperation();
}

// ❌ Dårlig: Stille feil
try { riskyOperation(); } catch(_) {} // Skjuler problemer
```

### **Async Operations**
```javascript
// ✅ Bra: Promise-basert med fallback
const result = operation();
if (result?.then) {
  result.then(onSuccess).catch(onError);
} else {
  setTimeout(onSuccess, 300); // Fallback
}

// ❌ Dårlig: Kun timeout
setTimeout(onSuccess, 200); // Hva hvis det tar lengre tid?
```

---

## 📋 Code Review Checklist

Ved code review, spør:

### **Eleganse**
- [ ] Er dette den enkleste løsningen som fungerer?
- [ ] Kan kompleksiteten reduseres uten å miste funksjonalitet?
- [ ] Er årsak-virkning-forholdet tydelig?

### **Robusthet**
- [ ] Håndteres edge cases og feil eksplisitt?
- [ ] Er løsningen timing-uavhengig?
- [ ] Fungerer det ved treg nettverksforbindelse?

### **Vedlikeholdbarhet**
- [ ] Kan en ny utvikler forstå koden uten lang forklaring?
- [ ] Er avhengigheter mellom moduler minimert?
- [ ] Er state-endringer forutsigbare?

---

## 🎯 Eksempler fra prosjektet

### **Bra refaktorering: Firebase race condition**
```javascript
// Før (komplekst): Suppression-flags og timing
notifyStateReset(); // Cross-module koordinering
setTimeout(pushState, 200); // Timing-avhengig

// Etter (elegant): Disable → Modify → Enable
unbindControlRead();
pushStateNow().then(() => bindControlReadHandlers(ref));
```

### **Bra refaktorering: Bump-effekt isolation**
```javascript
// Før (komplekst): DOM-sjekking og suppression
if(elA?.classList.contains('pop') || elB?.classList.contains('pop')) return;

// Etter (elegant): Global flag
if(_bumpInProgress) return;
```

---

## 💡 Når du er i tvil

1. **Start enkelt** - implementer den mest direkte løsningen først
2. **Refaktorer ved behov** - ikke over-engineer på forhånd  
3. **Spør deg selv:** "Vil jeg forstå denne koden om 6 måneder?"
4. **Test edge cases** - spesielt timing og nettverksfeil

---

*"Perfection is achieved, not when there is nothing more to add, but when there is nothing left to take away." - Antoine de Saint-Exupéry*


--------------------------------------------------
File End
--------------------------------------------------


docs\ARCHITECTURE_TODO.md
File type: .md
# 🏗️ Arkitektur TODO - Forbedringspotensial i BadmintonTeller

Basert på gjennomgang av kodebasen mot arkitekturprinsippene i `ARCHITECTURE.md`.

---

## 🔥 **HØYEST PRIORITET - Kritiske arkitekturproblemer**

### **1. matchView.js - God Object Problem**
- **Problem:** 20 imports, 1190+ linjer, ansvar for alt
- **Brudd på:** Single Responsibility, Separation of Concerns  
- **Gevinst:** Massiv reduksjon i kompleksitet og vedlikeholdbarhet
- **Løsning:** Split i `MatchController`, `MatchUI`, `MatchEvents`
- **Estimat:** 3-5 dager, høy risiko
- **Status:** ⏳ Pending

### **2. Callback Injection Pattern**
- **Problem:** `setControlReadDependencies()`, `setSpectatorDependencies()` etc.
- **Brudd på:** Tight coupling, indirekte koblinger
- **Gevinst:** Løsere kobling, lettere testing
- **Løsning:** Event-basert kommunikasjon eller observables
- **Estimat:** 2-3 dager, medium risiko
- **Status:** ⏳ Pending

### **3. Swap Suppression System**
- **Problem:** `_lastSwapTime`, `SWAP_SUPPRESS_MS` - timing-avhengig
- **Brudd på:** Timing-avhengig kode, symptombehandling
- **Gevinst:** Eliminerer race conditions
- **Løsning:** Bruk disable/enable pattern som vi gjorde for reset
- **Estimat:** 1 dag, lav risiko
- **Status:** ⏳ Pending

---

## 🔥 **HØY PRIORITET - Store arkitekturproblemer**

### **4. Firebase-UI Tight Coupling**
- **Problem:** UI-moduler importerer direkte fra Firebase
- **Brudd på:** Separation of Concerns
- **Gevinst:** Lettere testing, mindre avhengigheter
- **Løsning:** Firebase abstraction layer
- **Estimat:** 2-3 dager, medium risiko
- **Status:** ⏳ Pending

### **5. State Synchronization Chaos**
- **Problem:** Forskjellige patterns i `spectator.js` vs `controlRead.js`
- **Brudd på:** Konsistens, forutsigbarhet
- **Gevinst:** Enhetlig state-håndtering
- **Løsning:** Felles state sync interface
- **Estimat:** 2-3 dager, medium risiko
- **Status:** ⏳ Pending

### **6. Modal System Fragmentering**
- **Problem:** Hver modal har sin egen setup/teardown logikk
- **Brudd på:** DRY, konsistens
- **Gevinst:** Mindre kode, færre bugs
- **Løsning:** Felles modal manager
- **Estimat:** 1-2 dager, lav risiko
- **Status:** ⏳ Pending

---

## 🔥 **MEDIUM PRIORITET - Viktige forbedringer**

### **7. Event Binding Patterns**
- **Problem:** Inkonsistent binding/unbinding på tvers av moduler
- **Brudd på:** Predictable patterns
- **Gevinst:** Færre memory leaks, konsistens
- **Løsning:** Felles event binding interface
- **Estimat:** 1-2 dager, lav risiko
- **Status:** ⏳ Pending

### **8. Error Handling Standardisering**
- **Problem:** `try { } catch(_) {}` overalt, ingen konsistent strategi
- **Brudd på:** Fail fast & graceful degradation
- **Gevinst:** Bedre debugging, mer robust
- **Løsning:** Felles error handling utilities
- **Estimat:** 1-2 dager, lav risiko
- **Status:** ⏳ Pending

### **9. Timing Dependencies Eliminering**
- **Problem:** Mange `setTimeout()` for koordinering
- **Brudd på:** Timing-uavhengig kode
- **Gevinst:** Mer pålitelig, mindre race conditions
- **Løsning:** Promise-baserte patterns
- **Estimat:** 2-3 dager, medium risiko
- **Status:** ⏳ Pending

---

## 🔥 **LAV PRIORITET - Kodekvalitet**

### **10. Local-Only Mode UX**
- **Problem:** Bruker får kun toast-varsel om local-only mode, begrenset funksjonalitet
- **Brudd på:** User experience, clear communication
- **Gevinst:** Tydelig kommunikasjon og begrenset funksjonalitet i offline-modus
- **Løsning:** Modal-varsel, deaktiver deling/multi-user, visuell indikator
- **Estimat:** 1-2 dager, lav risiko
- **Status:** ⏳ Pending

### **11. Code Duplication Eliminering**
- **Problem:** Lignende patterns repetert på tvers av filer
- **Brudd på:** DRY principle
- **Gevinst:** Mindre kode å vedlikeholde
- **Løsning:** Extract common utilities
- **Estimat:** 1-2 dager, lav risiko
- **Status:** ⏳ Pending

---

## 📊 **Anbefalt implementeringsrekkefølge:**

### **Fase 1: Quick Wins (1-2 uker)**
1. **Local-Only Mode UX** → Modal-varsel og begrenset funksjonalitet
2. **Swap Suppression System** → Anvend reset-pattern
3. **Modal System** → Felles manager
4. **Event Binding** → Konsistente patterns

### **Fase 2: Core Architecture (3-4 uker)**
5. **Callback Injection** → Event-basert kommunikasjon
6. **State Synchronization** → Felles interface
7. **Firebase Coupling** → Abstraction layer

### **Fase 3: The Big One (4-6 uker)**
8. **matchView.js Refaktorering** → Split i moduler

### **Fase 4: Polish (1-2 uker)**
9. **Error Handling** → Standardisering
10. **Timing Dependencies** → Promise-basert
11. **Code Duplication** → Utilities

---

## 🎯 **Suksesskriterier:**

### **Etter Fase 1:**
- ✅ Tydelig brukervarsel for local-only mode
- ✅ Ingen timing-baserte suppression systems
- ✅ Konsistent modal-håndtering
- ✅ Forutsigbare event patterns

### **Etter Fase 2:**
- ✅ Løs kobling mellom moduler
- ✅ Enhetlig state synchronization
- ✅ Testbar Firebase-integrasjon

### **Etter Fase 3:**
- ✅ matchView.js under 400 linjer
- ✅ Klare ansvarsområder per modul
- ✅ Maksimalt 8 imports per fil

### **Etter Fase 4:**
- ✅ Konsistent error handling
- ✅ Ingen setTimeout-koordinering
- ✅ Minimal code duplication

---

## 💡 **Implementeringstips:**

1. **En oppgave av gangen** - Ikke bland refaktoreringer
2. **Test grundig** - Spesielt state sync og Firebase-integrasjon
3. **Behold funksjonalitet** - Ingen nye features under refaktorering
4. **Dokumenter endringer** - Oppdater REFACTOR_LOG.md
5. **Bruk arkitekturprinsippene** - Referer til ARCHITECTURE.md

---

## ✅ **FERDIG IMPLEMENTERT (2025-10-02)**

### **Router System og Multi-User Write Access**
- **Implementert:** Sentral router i `main.js` som håndterer URL-parametere (`mode`, `game`)
- **Implementert:** Early router i `index.html` som forhindrer splash-flicker
- **Implementert:** Multi-user write access system med `writeAccess.js`
- **Implementert:** Firebase local-only fallback mode med brukervarsel
- **Implementert:** Graceful degradation når Firebase permissions feiler
- **Status:** ✅ Complete

### **Firebase Integration Improvements**
- **Implementert:** Atomic writes for initial game data med `hostUid`
- **Implementert:** Read suppression etter write errors for å unngå race conditions
- **Implementert:** Async `getStateForSync()` med proper error handling
- **Status:** ✅ Complete

---

*Oppdatert: 2025-10-02*  
*Estimert total innsats: 12-18 uker*  
*Forventet gevinst: 80% reduksjon i kompleksitet og vedlikeholdskost*


--------------------------------------------------
File End
--------------------------------------------------


docs\CONSOLIDATION_TODO.md
File type: .md
# 🏸 Konsolidering og Navngiving TODO

Basert på diskusjon om å forenkle spectator/controlRead-systemet og innføre badminton-spesifikke navn.

---

## 🎯 **NAVNGIVING - Anbefaling**

### **Roller (brukervendte):**
- **Counter** - Personen som teller (erstatter "controller")
- **Spectator** - Publikum som ser på (beholdes)
- **Reader** - Counter uten skrivetilgang (ny rolle)

### **Tekniske modi:**
- **Counter mode** - Aktiv telling med skrivetilgang
- **Reader mode** - Passiv telling uten skrivetilgang  
- **Spectator mode** - Kun visning

### **URL-struktur:**
```
// Nåværende:
?mode=spectator    ✅ Beholdes

// Nye:
?mode=counter      (erstatter ?mode=control)
?mode=reader       (ny - counter uten skrivetilgang)

// Med tokens (fremtid):
?token=counter-abc123
?token=reader-abc123
?token=spectator-abc123
```

---

## 🔥 **FASE 1: Navngiving og Konsolidering (1-2 uker)**

### **1.1 Navngiving gjennom kodebasen**
- **Problem:** "control/controller" brukes inkonsistent
- **Løsning:** Erstatt med "counter" overalt
- **Estimat:** 2-3 dager, lav risiko
- **Status:** ⏳ Pending

**Konkrete endringer:**
```javascript
// URL parsing
'control' → 'counter'

// Variabler
controlRead.js → counterSync.js (eller firebaseSync.js)
bindControlReadHandlers → bindCounterSync
setControlReadDependencies → setCounterDependencies

// Kommentarer og dokumentasjon
"kontroll-modus" → "counter-modus"
"control client" → "counter client"
```

### **1.2 Konsolider spectator.js og controlRead.js**
- **Problem:** Duplikasjon av Firebase-lytting logikk
- **Løsning:** Felles firebaseSync.js modul
- **Estimat:** 3-4 dager, medium risiko
- **Status:** ⏳ Pending

**Ny struktur:**
```javascript
// firebaseSync.js (ny fil)
export function bindFirebaseSync(options) {
  const { mode, onUpdate, canWrite } = options;
  // Felles logikk for alle Firebase-lytting
}

// Bruk:
bindFirebaseSync({ mode: 'counter', onUpdate: updateUI, canWrite: true });
bindFirebaseSync({ mode: 'spectator', onUpdate: updateUI, canWrite: false });
bindFirebaseSync({ mode: 'reader', onUpdate: updateUI, canWrite: false });
```

### **1.3 Introduser "Reader" rolle**
- **Problem:** Counter uten skrivetilgang trenger eget navn
- **Løsning:** Ny "reader" rolle
- **Estimat:** 1 dag, lav risiko
- **Status:** ⏳ Pending

**Implementering:**
```javascript
// roles.js (ny fil)
export const ROLES = {
  SPECTATOR: 'spectator',  // Kun visning
  READER: 'reader',        // Counter uten skrivetilgang
  COUNTER: 'counter'       // Counter med skrivetilgang
};

export function getCurrentRole() {
  const mode = getURLMode();
  return ROLES[mode.toUpperCase()] || ROLES.SPECTATOR;
}
```

---

## 🔥 **FASE 2: Security-Ready Architecture (1-2 uker)**

### **2.1 Permission abstraction layer**
- **Problem:** Hardkodet tilgangskontroll spredt i koden
- **Løsning:** Sentral permissions.js modul
- **Estimat:** 2-3 dager, lav risiko
- **Status:** ⏳ Pending

```javascript
// permissions.js (ny fil)
export function canWrite(gameId, action) {
  const role = getCurrentRole();
  const token = getCurrentToken();
  
  // Nå: Enkel rolle-sjekk
  return role === 'counter';
  
  // Senere: Token-basert validering
}

export function canRead(gameId) {
  // Alltid true nå, klar for fremtidige restriksjoner
  return true;
}
```

### **2.2 Token-basert tilgangskontroll (grunnlag)**
- **Problem:** Kun URL-basert tilgangskontroll
- **Løsning:** Token-parsing og lagring
- **Estimat:** 2-3 dager, medium risiko
- **Status:** ⏳ Pending

```javascript
// tokens.js (ny fil)
export function getCurrentToken() {
  return new URLSearchParams(location.search).get('token') || 
         localStorage.getItem('gameToken');
}

export function getTokenRole(token) {
  if (!token) return 'spectator';
  if (token.startsWith('counter-')) return 'counter';
  if (token.startsWith('reader-')) return 'reader';
  return 'spectator';
}
```

### **2.3 Sentral write actions**
- **Problem:** Spredte Firebase-skrivinger
- **Løsning:** Sentral writeActions.js modul
- **Estimat:** 1-2 dager, lav risiko
- **Status:** ⏳ Pending

```javascript
// writeActions.js (ny fil)
export async function writeScore(gameId, side, newScore) {
  if (!canWrite(gameId, 'score')) {
    throw new Error('Unauthorized');
  }
  
  // Nå: Direkte Firebase
  return pushStateNow();
  
  // Senere: Gjennom sikker endpoint med token-validering
}
```

---

## 🔥 **FASE 3: Fremtidig sikkerhet (senere)**

### **3.1 Firebase Security Rules**
- **Problem:** Ingen server-side validering
- **Løsning:** Firebase rules basert på tokens
- **Estimat:** 1-2 dager, medium risiko
- **Status:** 📋 Future

### **3.2 QR-kode generering**
- **Problem:** Vanskelig å dele tilgang
- **Løsning:** QR-koder med embedded tokens
- **Estimat:** 2-3 dager, lav risiko
- **Status:** 📋 Future

### **3.3 Token management**
- **Problem:** Ingen token-administrasjon
- **Løsning:** Admin-interface for token-generering
- **Estimat:** 3-4 dager, medium risiko
- **Status:** 📋 Future

---

## 📊 **Implementeringsrekkefølge:**

### **Uke 1-2: Grunnleggende opprydding**
1. **Navngiving** - controller → counter
2. **Konsolidering** - spectator.js + controlRead.js → firebaseSync.js
3. **Reader rolle** - Ny rolle for counter uten skrivetilgang

### **Uke 3-4: Security-ready**
4. **Permission layer** - Abstraher tilgangskontroll
5. **Token parsing** - Grunnlag for token-system
6. **Write actions** - Sentral skrivetilgang

### **Senere: Full sikkerhet**
7. **Firebase rules** - Server-side validering
8. **QR-koder** - Enkel tilgangsdeling
9. **Token admin** - Administrasjonsgrensesnitt

---

## 🎯 **Suksesskriterier:**

### **Etter Fase 1:**
- ✅ Konsistent "counter" terminologi
- ✅ Én Firebase sync-modul i stedet for to
- ✅ Tydelige roller: spectator/reader/counter

### **Etter Fase 2:**
- ✅ Abstrakt permission-system
- ✅ Token-basert tilgangskontroll (grunnlag)
- ✅ Sentral write-funksjonalitet

### **Etter Fase 3:**
- ✅ Ekte sikkerhet med server-side validering
- ✅ QR-basert tilgangsdeling
- ✅ Komplett token-administrasjon

---

## 💡 **Navngiving - Endelig anbefaling:**

### **Brukervendte termer:**
- **Counter** ✅ (erstatter controller)
- **Spectator** ✅ (beholdes)
- **Reader** ✅ (ny - counter uten skrivetilgang)

### **Tekniske termer:**
- **firebaseSync.js** ✅ (erstatter spectator.js + controlRead.js)
- **permissions.js** ✅ (ny - tilgangskontroll)
- **tokens.js** ✅ (ny - token-håndtering)
- **writeActions.js** ✅ (ny - sikre skrivinger)

### **URL-struktur:**
```
?mode=spectator  ✅ (beholdes)
?mode=counter    ✅ (erstatter control)
?mode=reader     ✅ (ny rolle)

// Fremtid:
?token=counter-abc123
?token=reader-abc123
```

---

*Estimert total tid: 4-6 uker*  
*Hovedgevinst: Enklere arkitektur + security-ready foundation*


--------------------------------------------------
File End
--------------------------------------------------


docs\ignore-files.md
File type: .md
# Ignore Files

## output.txt
This file contains a dump/printout of all code and can be safely ignored during development and code analysis.

**Why it exists:** Likely generated for debugging or documentation purposes.

**Action:** Ignore this file completely when:
- Searching for code patterns
- Analyzing duplicates
- Making code changes
- Reviewing functionality

The actual source code is in the `js/` directory and other project files.



--------------------------------------------------
File End
--------------------------------------------------


docs\IMPLEMENTATION_ROADMAP.md
File type: .md
# 🚀 Implementation Roadmap - BadmintonTeller Refaktorering

Komplett plan for konsolidering, navngiving og security-ready arkitektur.

---

## 🎯 **OVERORDNET MÅL**
Transformere BadmintonTeller fra kompleks, duplikert kode til elegant, security-ready arkitektur med badminton-spesifikk terminologi.

---

## ✅ **FASE 0: FERDIG IMPLEMENTERT (2025-10-02)**
*Router system og multi-user write access*

### **✅ IMPLEMENTERT**

#### **Router System**
- **Implementert:** Sentral router i `main.js` for URL-parametere
- **Implementert:** Early router i `index.html` mot splash-flicker
- **Implementert:** URL cleaning for navigation tilbake til splash
- **Status:** ✅ Complete

#### **Multi-User Write Access**
- **Implementert:** `writeAccess.js` med claim/release funksjonalitet
- **Implementert:** Firebase security rules for `currentWriter` field
- **Implementert:** Local-only fallback mode med brukervarsel
- **Status:** ✅ Complete

---

## 📋 **FASE 1: Local-Only Mode UX (1 uke)**
*Forbedre brukeropplevelse i offline-modus*

### **🔥 HØY PRIORITET**

#### **1.1 Local-Only Mode UX**
- **Problem:** Bruker får kun toast-varsel, begrenset funksjonalitet
- **Løsning:** Modal-varsel, deaktiver deling/multi-user, visuell indikator
- **Estimat:** 1-2 dager, lav risiko
- **Status:** ⏳ Pending

---

## 📋 **FASE 2: Pre-konsolidering (1 uke)**
*Kritiske forberedelser som må gjøres først*

### **🔥 KRITISK (må gjøres først)**

#### **2.1 Swap Suppression Fix**
- **Problem:** Timing-basert `_lastSwapTime` suppression system
- **Løsning:** Bruk disable/enable pattern som vi gjorde for reset
- **Estimat:** 1 dag, lav risiko
- **Hvorfor først:** Konsolideringen vil røre ved samme kode
- **Status:** ⏳ Pending

#### **2.2 Bump-effekt Stabilisering**
- **Problem:** Sikre at bump-systemet er 100% stabilt
- **Løsning:** Grundig testing av nylig implementerte endringer
- **Estimat:** 0.5 dag, lav risiko
- **Hvorfor først:** Ustabil kode gjør konsolidering risikofylt
- **Status:** ⏳ Pending

### **🚀 QUICK WIN (høy synlig gevinst)**

#### **2.3 Navngiving - Controller → Counter**
- **Problem:** "Controller" er ikke badminton-spesifikt
- **Løsning:** Erstatt med "counter" gjennom hele kodebasen
- **Estimat:** 2 dager, lav risiko
- **Gevinst:** Domene-spesifikt språk, lettere å forstå
- **Status:** ⏳ Pending

**Konkrete endringer:**
```javascript
// URL parsing
'control' → 'counter'

// Filer
controlRead.js → counterSync.js (midlertidig, før konsolidering)

// Funksjoner
bindControlReadHandlers → bindCounterSync
setControlReadDependencies → setCounterDependencies

// Kommentarer
"kontroll-modus" → "counter-modus"
"control client" → "counter client"
```

### **⚠️ VURDER (kan spare tid senere)**

#### **2.4 Minimal Firebase Abstraction**
- **Problem:** Konsolidering vil lage ny Firebase-kode
- **Løsning:** Grunnleggende abstraction før konsolidering
- **Estimat:** 2-3 dager, medium risiko
- **Vurdering:** Kan unngå dobbel refaktorering
- **Status:** 🤔 Under vurdering

#### **2.5 Error Handling Patterns**
- **Problem:** Inkonsistent error handling vil påvirke konsolidert kode
- **Løsning:** Definer standarder først
- **Estimat:** 1 dag, lav risiko
- **Vurdering:** Gjør konsolideringen renere
- **Status:** 🤔 Under vurdering

---

## 📋 **FASE 3: Konsolidering (2-3 uker)**
*Hovedrefaktorering av spectator/controlRead systemet*

### **3.1 Firebase Sync Konsolidering**
- **Problem:** spectator.js og controlRead.js dupliserer Firebase-lytting
- **Løsning:** Felles firebaseSync.js modul
- **Estimat:** 3-4 dager, medium risiko
- **Status:** ⏳ Pending

**Ny arkitektur:**
```javascript
// firebaseSync.js (erstatter spectator.js + controlRead.js)
export function bindFirebaseSync(options) {
  const { role, onUpdate, canWrite } = options;
  
  // Felles logikk for alle Firebase-lytting
  // Samme patterns for spectator, reader og counter
}

// Bruk:
bindFirebaseSync({ role: 'counter', onUpdate: updateUI, canWrite: true });
bindFirebaseSync({ role: 'reader', onUpdate: updateUI, canWrite: false });
bindFirebaseSync({ role: 'spectator', onUpdate: updateUI, canWrite: false });
```

### **1.2 Reader Rolle Introduksjon**
- **Problem:** Counter uten skrivetilgang trenger eget navn
- **Løsning:** Ny "reader" rolle mellom spectator og counter
- **Estimat:** 1-2 dager, lav risiko
- **Status:** ⏳ Pending

**Rolle-hierarki:**
```javascript
// roles.js (ny fil)
export const ROLES = {
  SPECTATOR: 'spectator',  // Kun visning, ingen kontroller
  READER: 'reader',        // Counter-visning uten skrivetilgang
  COUNTER: 'counter'       // Full counter med skrivetilgang
};

// URL-struktur
?mode=spectator  // Publikum
?mode=reader     // Counter uten skrivetilgang
?mode=counter    // Full counter
```

### **1.3 Callback Injection Eliminering**
- **Problem:** `setControlReadDependencies()`, `setSpectatorDependencies()` etc.
- **Løsning:** Event-basert kommunikasjon
- **Estimat:** 2-3 dager, medium risiko
- **Status:** ⏳ Pending

---

## 📋 **FASE 4: Security-Ready Architecture (2-3 uker)**
*Forberede for fremtidig token-basert sikkerhet*

### **4.1 Permission Abstraction Layer**
- **Problem:** Hardkodet tilgangskontroll spredt i koden
- **Løsning:** Sentral permissions.js modul
- **Estimat:** 2-3 dager, lav risiko
- **Status:** ⏳ Pending

```javascript
// permissions.js (ny fil)
export function canWrite(gameId, action) {
  const role = getCurrentRole();
  const token = getCurrentToken();
  
  // Nå: Enkel rolle-sjekk
  return role === 'counter';
  
  // Senere: Token-basert validering
  // return validateToken(token, gameId, action);
}
```

### **2.2 Token-basert Tilgangskontroll (Grunnlag)**
- **Problem:** Kun URL-basert tilgangskontroll
- **Løsning:** Token-parsing og lagring (uten innlogging)
- **Estimat:** 2-3 dager, medium risiko
- **Status:** ⏳ Pending

```javascript
// tokens.js (ny fil)
export function getCurrentToken() {
  return new URLSearchParams(location.search).get('token') || 
         localStorage.getItem('gameToken');
}

export function getTokenRole(token) {
  if (!token) return 'spectator';
  if (token.startsWith('counter-')) return 'counter';
  if (token.startsWith('reader-')) return 'reader';
  return 'spectator';
}
```

### **2.3 Sentral Write Actions**
- **Problem:** Spredte Firebase-skrivinger
- **Løsning:** Sentral writeActions.js modul
- **Estimat:** 1-2 dager, lav risiko
- **Status:** ⏳ Pending

```javascript
// writeActions.js (ny fil)
export async function writeScore(gameId, side, newScore) {
  if (!canWrite(gameId, 'score')) {
    throw new Error('Unauthorized');
  }
  
  // Nå: Direkte Firebase
  return pushStateNow();
  
  // Senere: Med token-validering og audit trail
}
```

---

## 📋 **FASE 5: Fremtidig Sikkerhet (senere)**
*Full token-basert sikkerhet når det trengs*

### **5.1 Firebase Security Rules**
- **Løsning:** Server-side validering basert på tokens
- **Estimat:** 1-2 dager, medium risiko
- **Status:** 📋 Future

### **5.2 QR-kode Generering**
- **Løsning:** QR-koder med embedded tokens for enkel tilgangsdeling
- **Estimat:** 2-3 dager, lav risiko
- **Status:** 📋 Future

### **5.3 Token Management**
- **Løsning:** Admin-interface for token-generering og -administrasjon
- **Estimat:** 3-4 dager, medium risiko
- **Status:** 📋 Future

---

## 🎯 **SUKSESSKRITERIER**

### **Etter Fase 0:**
- ✅ Ingen timing-baserte suppression systems
- ✅ Stabilt bump-effekt system
- ✅ Konsistent "counter" terminologi
- ✅ (Valgfritt) Grunnleggende Firebase abstraction

### **Etter Fase 1:**
- ✅ Én Firebase sync-modul i stedet for to
- ✅ Tydelige roller: spectator/reader/counter
- ✅ Event-basert kommunikasjon i stedet for callback injection
- ✅ 50% reduksjon i duplikert kode

### **Etter Fase 2:**
- ✅ Abstrakt permission-system
- ✅ Token-basert tilgangskontroll (grunnlag)
- ✅ Sentral write-funksjonalitet
- ✅ Klar for fremtidig sikkerhet uten store endringer

### **Etter Fase 3:**
- ✅ Ekte sikkerhet med server-side validering
- ✅ QR-basert tilgangsdeling
- ✅ Komplett token-administrasjon

---

## 📊 **RISIKO OG MITIGERING**

### **Høy risiko oppgaver:**
- **Firebase sync konsolidering** - Kan påvirke alle brukere
- **Mitigering:** Grundig testing, gradvis utrulling

### **Medium risiko oppgaver:**
- **Callback injection eliminering** - Kan påvirke event handling
- **Mitigering:** Behold gamle patterns til nye er testet

### **Lav risiko oppgaver:**
- **Navngiving** - Kun kosmetiske endringer
- **Permission abstraction** - Additive endringer

---

## ⏰ **TIDSESTIMAT**

### **Total tid:**
- **Fase 0:** 1 uke (3-6 dager)
- **Fase 1:** 2-3 uker (8-15 dager)  
- **Fase 2:** 2-3 uker (8-15 dager)
- **Fase 3:** Senere (8-12 dager)

### **Minimum Viable Product:**
- **Kun Fase 0 + 1.1:** 2-3 uker
- **Gevinst:** Eliminerer duplikasjon, bedre navngiving
- **Risiko:** Lav til medium

---

## 🚀 **ANBEFALT START**

### **Umiddelbar start (denne uken):**
1. **Swap suppression fix** (1 dag)
2. **Bump-effekt testing** (0.5 dag)
3. **Navngiving controller → counter** (2 dager)

### **Neste uke:**
4. **Vurder Firebase abstraction** (2-3 dager)
5. **Start Firebase sync konsolidering** (3-4 dager)

**Dette gir deg rask fremgang med lav risiko og synlige forbedringer!** 🎯

---

*Opprettet: 2025-01-02*  
*Estimert ferdigstillelse Fase 1-2: 6-8 uker*  
*Hovedgevinst: Elegant, security-ready arkitektur med badminton-terminologi*


--------------------------------------------------
File End
--------------------------------------------------


docs\README_transition.md
File type: .md
# BadmintonTeller – ChatGPT Transition Guide

Dette dokumentet forklarer hvordan vi setter opp en ny ChatGPT-tråd når vi jobber videre med utviklingen av BadmintonTeller.

## Instruksjoner til ChatGPT
- Du skal alltid formulere utviklingsoppgaver som **Cursor-prompts** i formatet fra md-filene våre (f.eks. `fix-small.md`, `feature-small.md`).
- Bruk alltid riktig mal (fix-small, feature-small).
- Inkluder: type, tittel, brukerhistorie, akseptanse, scope, tilnærming, test.
- Hold oppgavene **små og isolerte**, så de kan gjøres trinnvis.
- Oppretthold **backward compatibility** og gjør kun additive endringer i Firebase (aldri bryt eksisterende spectator-flyt).
- All skriving skal gå gjennom `safePush` og kun fra `writer`.
- Oversikt/spectator skal alltid være **read-only**.

## Teknologisk kontekst
- **Type prosjekt:** ES5-kompatibel webapp, frontend-only med Firebase RTDB.
- **Struktur:** modulbasert (`js/services`, `js/ui`, `js/state`, `js/utils`).
- **Arbeidsflyt:**
  - Diskusjon og planlegging skjer i ChatGPT.
  - Cursor brukes til implementasjon via `feature-small` og `fix-small`-prompts.
  - Firebase-regler endres kun med additive hvitelister (f.eks. `/writer`, `/permissions`).

## Designprinsipper
- Additive endringer – ikke brekk eksisterende spectator-flyt.
- Kun writer får lov å skrive.
- Ingen init-push i kontroll-modus.
- Bruk `enterMatch/exitMatch`-hooks i match-UI for ryddig mount/unmount.
- All skriving rutes via `safePush` og `mutations.js`.

## Kjente problemområder
- Dobbel-binding av event listeners i match-UI.
- Blink/flimmer i UI ved snapshots.
- Init-push på feil tidspunkt (overstyrer state).
- Skriving spredt i match-fila (for tett kobling).

## Overordnet mål
En webapp som lar frivillige telle badmintonkamper og administrere enkle turneringer. 
Appen skal fungere uten innlogging, støtte QR-koder/tokens for tilgang, og ha spectator/dashboard-visning i hallen.

## Visjon
- Kun én teller (writer) kan ha skrivelås på en kamp av gangen.  
- Andre kan være readers (spectator) men kan overta låsen med en knapp hvis de har riktig token.  
- Turneringer skal ha en live kampoversikt (dashboard) med snapshot av alle kamper.  
- Enkeltkamper skal kunne deles med QR.  

## Refactor-behov (grunnarbeid)
- **Init-push i kontroll:** fjernes, skriv kun når vi har claim’et skrivelås.  
- **Skriving spredt i match-fila:** samles i `mutations.js` + `safePush()`.  
- **Kontroll leser ikke RTDB:** legg til `bindControlReadHandlers(ref)`.  
- **Ingen enter/exit-hooks:** legg til `enterMatch/exitMatch` med cleanup.  
- **Role-gating mangler:** innfør `state.role` (`writer`/`reader`/`observer`).  
- **Echo-loop i writer:** ignorér snapshots som matcher egen siste write (ts/hash).  

## Planlagte funksjoner
### Enkeltkamp delt kontroll (MVP)
- QR-URL: `?mode=match&game=<gid>&match=<mid>&token=<t>`  
- Token gir rettigheter (`permissions/<matchId>/<token> = 'scorer'`).  
- Første åpner blir Writer. Andre blir Reader, men kan trykke **Overta**.  
- Writer kan slippe lås (Bytt til spectator).  
- Reader får disabled scoring/Neste sett/Ferdigstill.  

### Dashboard (turnering)
- Ny URL: `?mode=dashboard&game=<gid>`  
- Lytter på RTDB og viser oversikt.  
- Aktiv kamp leser live scoreA/B, setsA/B fra rotfelter.  
- Andre kamper henter status/sluttsett fra `tournament.matchStates`.  

### Turnerings-snapshot
- Kontroll skriver atomisk `tournament.activeMatchId` og `tournament.matchStates[matchId]`.  
- Snapshot brukes i dashboard, ingen duplisering av live-score.  

### Admin-modus (senere)
- Admin-token gir rettigheter til å generere QR, korrigere poeng, styre permissions.  

### Statistikk/summary (senere)
- `matchMeta` (regler, deltakere).  
- `matchSummary` (status, sets, setScores).  

## Roadmap
1. Refactor grunnmur: safePush, mutations.js, enter/exit-hooks, bindControlReadHandlers, fjern init-push, state.role, echo-guard.  
2. Enkeltkamp delt kontroll: deviceId + token i URL, claimWriter/releaseWriter, UI-rolleindikator, Overta/Bytt til spectator, permissions.  
3. Dashboard + turneringssnapshot.  
4. Admin-modus og QR-generator.  
5. Statistikk/summary og historikk.  


--------------------------------------------------
File End
--------------------------------------------------


docs\REFACTOR_LOG.md
File type: .md
# Refactor Logg (små, trygge PR-er)

Denne filen føres KUN for **refaktorering/rydding** (ikke features). Etter hver liten refaktor-PR:

1. Kjør `npm run loc` i repo-roten.
2. Legg til en rad i tabellen under med **Dato**, **Totale linjer** (tallet fra kommandoen) og en **meget kort** beskrivelse av endringen.
3. Hold forklaringen til én setning. Detaljer hører hjemme i PR-beskrivelsen.

> Tellemåte: `scripts/loc-count.mjs` teller `.js/.ts/.css/.html/.md` rekursivt, ekskluderer `node_modules`, `dist`, `.git`, `assets`, `public`, `.github`, `build`, `coverage`, `.cache`. Juster ved behov.

## Historikk

| Dato       | Totale linjer | Endring                                          | Notat |
|------------|----------------|--------------------------------------------------|-------|
| 2025-10-02 | 7970           | Feat-04: Router system og multi-user write access   | Implementerte router for delte linker og multi-user kontroll med Firebase-sync |
| 2025-09-xx | 5314           | **Baseline**                                     | Utgangspunkt før rydding. |
| 2025-09-xx | 5375           | Refactor-01: felles `ui/modal.js`                | Fokusfelle/scroll-lås samlet; litt engangskost i LOC. |
| 2025-09-xx | 5242           | Refactor-02: felles autocomplete                 | Fjernet duplisering i Navn/Turnering. |
| 2025-09-xx | 5272           | Refactor-03: finish/share → `openModal`          | Backdrop/Esc håndtert sentralt. |
| 2025-09-xx | 5260           | Konsolider ▼-knapp-logikk                        | Én `updateDropdownButtons`. |
| 2025-09-xx | 5287           | Bugfix-runde (dropdown + click-outside)          | Ingen nye features; stabilitet. |
| 2025-09-30 | 5276           | Refactor-04: `matchView` → `saveIndividual`      | Siste direkte `pushPrev` fjernet fra UI. |
| 2025-01-27 | 4909           | Refactor-05: Legg til REFACTOR_LOG + LOC-teller  | Dokumentasjon og verktøy for å spore refaktorer. |
| 2025-01-27 | 4885           | Refactor-06: `bindNameInput` i `matchView`       | Fjernet 6 dupliserte blur-lyttere med felles helper. |
| 2025-01-27 | 4887           | Refactor-07: Fjern ubrukte imports               | Opprydding i 4 UI-filer uten funksjonsendring. |
| 2025-01-27 | 4924           | Feat-01: Lås turneringsoppsett etter start       | Skjul/deaktiver "Tilbake" når turnering er startet. |
| 2025-01-27 | 4942           | Fix-01: "Fortsett turnering" åpner alltid oversikt | Bypass auto-resume til enkeltkamp for turneringsoversikt. |
| 2025-01-27 | 4923           | Refactor-08: session-helper for "Fortsett"        | Fjernet duplisering av aktiv-kamp-sjekk og etikett. |
| 2025-01-27 | 4946           | Feat-02: Bekreftelsesdialog for "Start"           | Varsler før sletting av pågående kamp/turnering. |
| 2025-01-27 | 4993           | Feat-03: Styled modal for "Start" bekreftelse     | Erstatter window.confirm med pen modal. |
| 2025-01-27 | 5019           | Fix-02: "Gå til start" viser alltid "Fortsett"    | X-knapp og "Gå til start" sletter ikke state. |
| 2025-01-27 | 5030           | Fix-03: Bekreftelsesmodal viser korrekt tekst     | Sjekker faktisk aktiv state, ikke toggle. |
| 2025-01-27 | 5037           | Refactor-09: Batch DOM i tournamentOverview       | DocumentFragment reduserer reflow/repaint. |
| 2025-01-27 | 5056           | Fix-04: Start-bekreftelse rydder turneringsdata   | Sletter state før ny start, ikke etter. |
| 2025-01-27 | 5054           | Refactor-10: getDisplayName overalt               | Erstattet manuell string/objekt-logikk. |
| 2025-01-27 | 5059           | Refactor-11: konsistent getDisplayName i matchView | Lokal helper for A/B-visningsnavn. |
| 2025-01-27 | 5074           | Refactor-12: isAtStart helper for start-sjekk       | Felles helper for "er vi ved start?". |
| 2025-01-27 | 5063           | Refactor-13: Fjern maybeSaveNamesOnStart            | Fjernet ubrukt funksjon og state-flag. |
| 2025-01-27 | 5047           | Fix-05: Statistikk-modal vises ikke                 | Legger til .show-klasse i openModal/closeModal. |
| 2025-01-27 | 5083           | Fix-06: Statistikk-siden vises tom                  | Kobler kebab-aksjon til renderStats med fallback. |
| 2025-01-27 | 5086           | Fix-07: Statistikk-handler parameter mismatch       | Fikser renderStats-parametere i menu.js. |
| 2025-01-27 | 5092           | Fix-08: Statistikk placeholder-kommentar            | Håndterer HTML-kommentarer i ensureStatsShell. |

## Mal for nye rader

> Legg nederst i tabellen, nyeste først.

```
|| 2025-01-02 | ~6280 | Refactor-17: Firebase konsolidering spectator+counterRead → firebaseSync | Konsoliderte spectator.js og counterRead.js til én firebaseSync.js med rolle-basert oppførsel og eliminert duplikasjon |
|| 2025-01-02 | ~6280 | Refactor-16: Navngiving controller → counter/teller | Erstattet "control/controller" med "counter" (kode) og "teller" (GUI) for badminton-spesifikt språk |
|| 2025-01-02 | ~6280 | Refactor-15: Swap suppression - timing til disable/enable | Fjernet timing-basert suppression, erstattet med robust disable/enable pattern |
|| 2025-01-27 | 6270 | Refactor-14: Konsolider bump-logikk | Laget handleScoreBump() for å fjerne duplisering av bump-effekter |
|| 2024-12-19 | 5146 | Fix-09: Spectator vinnerglød | Rettet spectator til å vise vinnerglød basert på sett-telling i stedet for msg |
|| 2024-12-19 | 5124 | Refactor-17: DOM-helper utilities | Laget js/util/domUtils.js med qs/on/toggle helpers og byttet mikro-snutter |
|| 2024-12-19 | 5111 | Refactor-16: Dynamisk skriptlasting | Konsoliderte loadScript/loadScriptOnce til js/util/loadScript.js |
|| YYYY-MM-DD | <totale linjer> | Refactor-NN: <kort tittel> | <én kort setning om ryddingen> |
```

--------------------------------------------------
File End
--------------------------------------------------


docs\utf8-guide.md
File type: .md
﻿# UTF-8 Editing Guide

To keep Norwegian letters (æøå) and emoji intact, always save files in UTF-8. Follow these rules:

- **In VS Code**: check the status bar encoding. If it is not `UTF-8`, click it → *Save with Encoding…* → choose `UTF-8`. VS Code will remember this per file.
- **In PowerShell**: when writing files, always specify the encoding, e.g.
  ```powershell
  Set-Content -Path <file> -Value $content -Encoding utf8
  ```
  or
  ```powershell
  "text" | Out-File <file> -Encoding utf8
  ```
  Avoid bare `>` redirects or `Set-Content` without `-Encoding`, because older versions default to ASCII.
- **Optional safety**: run `chcp 65001` at the start of a shell session so the console uses UTF-8.
- **For icons**: using HTML entities like `&#x25BC;` for ▼ is a fallback when UTF-8 isn’t available.

Stick to these steps and the repo keeps its special characters healthy.


--------------------------------------------------
File End
--------------------------------------------------


docs\prompts\feature-small.md
File type: .md
# Feature-oppgave (liten, konkret)

**Type:** feat (se CONTRIBUTING.md)
**Brukerhistorie:**
Som <rolle> vil jeg <mål> slik at <verdi>.

**Akseptanse:**
- [ ] Når jeg gjør A, skjer B
- [ ] UI-tekst/knapp C vises når D
- [ ] Ingen regresjon i eksisterende flyt E

**Scope:** <filer/moduler>

**Output:**
- Diff + kort beskrivelse
- Manuell testliste (3–5 trinn)



--------------------------------------------------
File End
--------------------------------------------------


docs\prompts\fix-small.md
File type: .md
# Fix-oppgave (liten og konkret)

**Type:** fix (se CONTRIBUTING.md)

**Bruk når:**
- Du skal rette en bug eller uønsket oppførsel.
- Eksempel: knapp gjør feil ting, feil scroll-adferd, feil state ved reload.

**Regler:**
- Diff < 100 linjer (små fikser).
- Ingen nye features.
- Beskriv feilen tydelig.
- Sørg for at oppførsel matcher forventningene etter fix.

**Output (fra AI):**
- En diff med rettingen.
- Kort forklaring av hva som ble endret.
- En manuell testliste (hvordan jeg kan verifisere at bugen er borte).



--------------------------------------------------
File End
--------------------------------------------------


docs\prompts\README.md
File type: .md
# Prompt-bruk i BadmintonTeller

Her er oversikt over de ulike prompt-malene vi har laget, og hvordan du skal bruke dem i Cursor.

---

## 1. Refaktor (rydde opp, ingen nye funksjoner)
**Fil:** `docs/prompts/refactor-small.md`  
**Bruk når:** Du vil korte ned kode, fjerne duplisering, flytte logikk til egne moduler.  
**Regler:** Ingen nye features. Diff < 150 linjer. Samme oppførsel som før.  
**Slik bruker du i Cursor:**

```
Bruk @docs/prompts/refactor-small.md
Scope: js/ui/modal.js + bytte i nameModal.js og summary.js
Mål: samle åpne/lukke-logikken for modalene i én felles funksjon.
```

---

## 2. Feature (legge til ny funksjon)
**Fil:** `docs/prompts/feature-small.md`  
**Bruk når:** Du vil bygge en ny knapp, ny flyt, eller endre oppførsel brukeren ser.  
**Regler:** Beskriv en kort brukerhistorie + akseptansekriterier.  
**Slik bruker du i Cursor:**

```
Bruk @docs/prompts/feature-small.md
Brukerhistorie: Som spiller vil jeg se en timer på sett, slik at jeg vet hvor lenge det har vart.
Scope: js/ui/matchView.js
```

---

## 3. Fix (rette en bug)
**Fil:** `docs/prompts/fix-small.md`  
**Bruk når:** En knapp gjør feil ting, feil state settes, eller en annen uønsket oppførsel må rettes.  
**Regler:** Diff < 100 linjer. Ingen nye features.  
**Slik bruker du i Cursor:**
```
Bruk @docs/prompts/fix-small.md
Feil: "Lukk sammendragsmodal låser scroll etter lukking."
Forventet: Scroll skal være frigitt når modal er lukket.
Scope: js/ui/summary.js
```

---

## 4. Generelt tips
- Start alltid med å si hvilken type oppgave det er (`refactor`, `feat`, `fix`).  
- Peker du til en mal (`@docs/prompts/...`), så bruker Cursor reglene der automatisk.  
- Be alltid om en kort testliste tilbake, slik at du kan sjekke manuelt før du merger.
- **Les arkitekturprinsippene:** Se `@docs/ARCHITECTURE.md` for retningslinjer om elegant kode.

---

## 5. Arkitektur og kodestil
**Fil:** `docs/ARCHITECTURE.md`  
**Inneholder:** Prinsipper for elegant, vedlikeholdbar kode i BadmintonTeller.  
**Bruk når:** Du er usikker på hvordan du skal løse et problem, eller vil ha code review-kriterier.

---


--------------------------------------------------
File End
--------------------------------------------------


docs\prompts\refactor-small.md
File type: .md
# Refaktor-oppgave (liten og trygg)

**Type:** refactor (se CONTRIBUTING.md)
**Scope:** <angi filer/moduler>
**Mål:**
- Fjern duplisering X ved å flytte til <ny modul/func>
- Behold oppførsel uendret (ingen visuelle endringer)

**Regler:**
- Ikke legg til nye features
- Hold endringen avgrenset og liten
- Gjenbruk helpers (ui/modal, util/dom, state actions)
- Bytt inline styles → CSS-klasser der det er naturlig

**Output:**
- En kompakt diff
- Kort notat om hva som ble endret
- Liten manuell testliste (2–4 punkter)
- Oppdater REFACTOR_LOG.md med ny LOC og refactor-info

**Commit-prosess:**
1. **Etter refactoring:** Lag klar commit-melding med `git add` og `git commit -m "..."` kommandoer
2. **Før commit:** Spør bruker om de vil committe - la bruker teste først
3. **Bruker godkjenner:** Kjør commit-kommandoene
4. **Oppdater REFACTOR_LOG.md** med ny LOC og refactor-info


--------------------------------------------------
File End
--------------------------------------------------


js\constants.js
File type: .js
export const LONGPRESS_MS = 800;
export const MOVE_THRESH = 16;

export const LS = {
  MATCHES: 'badm_matches_v1',
  LAST: 'badm_last_names_v1',
  LIVE: 'badm_live_v1',
  GAME_ID: 'badm_game_id_v3',
  KB_TIP: 'badm_kebab_tip_v1',
  PREV: 'badm_prev_names_v3'
};


--------------------------------------------------
File End
--------------------------------------------------


js\dom.js
File type: .js
export function $(selector){
  return document.querySelector(selector);
}

export function toast(msg){
  var t = document.getElementById('toast');
  if(!t) return;
  t.textContent = msg;
  t.style.display = 'block';
  setTimeout(function(){ t.style.display = 'none'; }, 1400);
}

export function qs(name){
  try{
    return new URL(location.href).searchParams.get(name);
  }catch(_){
    return null;
  }
}

export function setBodyScroll(lock){
  document.body.classList.toggle('no-scroll', !!lock);
}


--------------------------------------------------
File End
--------------------------------------------------


js\main.js
File type: .js
import { state } from './state/matchState.js';
import { mount, startMatchFlow, restoreFromStorage, applyRestoredState } from './ui/matchView.js';
import { showSplash, hideSplash, setSplashContinueState } from './ui/splash.js';
import { hasActiveMatchState, getContinueLabel } from './ui/session.js';
import { setupStatsModal } from './ui/statsView.js';
import { bindDashboardHandlers, ensureGameId } from './services/firebase.js';
import { renderTournamentOverviewFromSnapshot } from './ui/tournamentOverview.js';

// Felles helper for å gå til start uten å slette state
export function goToStart(options){
  options = options || {};
  if (!state.ui) state.ui = {};
  state.ui.requestSplashButtonsRefresh = true; // hint splash om å oppdatere knapper
  
  // Close any open modals
  try { 
    const closeAllModals = window.closeAllModals;
    if (closeAllModals) closeAllModals(); 
  } catch(_) {}
  
  // Clean URL when going to start (remove mode/game parameters)
  cleanUrlForSplash();
  
  // Show splash
  showSplash();
}

// Helper to clean URL parameters when returning to splash
function cleanUrlForSplash() {
  try {
    const url = new URL(window.location);
    const hasParams = url.searchParams.has('mode') || url.searchParams.has('game');
    
    if (hasParams) {
      url.searchParams.delete('mode');
      url.searchParams.delete('game');
      window.history.replaceState({}, '', url.toString());
    }
  } catch(e) {
    // Ignore URL manipulation errors
  }
}

// Router helper: Navigate to counter mode (removes cocounter from URL)
export function navigateToCounterMode() {
  try {
    const url = new URL(window.location);
    url.searchParams.delete('mode'); // Remove mode to default to counter
    window.history.replaceState({}, '', url.toString());
    
    // Re-initialize with new mode instead of full reload
    setTimeout(() => {
      window.location.reload(); // For now, still reload to ensure clean state
    }, 0);
  } catch(e) {
    console.warn('Failed to navigate to counter mode:', e);
    window.location.reload(); // Fallback
  }
}

function parseQuery(){
  try {
    var params = new URL(location.href).searchParams;
    return {
      mode: params.get('mode'),
      game: params.get('game')
    };
  } catch(_) {
    return {};
  }
}

function boot(){
  mount();
  setupStatsModal();

  const params = parseQuery();
  
  // Router: Handle different URL modes
  switch(params.mode) {
    case 'dashboard':
      return bootDashboard(params);
    case 'spectator':
    case 'counter': 
    case 'cocounter':
      return bootMatch(params);
    default:
      return bootSplash();
  }
}

// Dashboard mode boot
function bootDashboard(params) {
  if (!params.game) {
    console.warn('Dashboard mode requires game ID, redirecting to splash');
    return bootSplash();
  }
  
  state.IS_DASHBOARD = true;
  // Initialize Firebase and bind dashboard handlers
  import('./services/firebase.js').then(function(module) {
    module.setupFirebase({});
    // Wait for Firebase to be ready, then bind handlers
    setTimeout(function() {
      if (window.firebase && firebase.database) {
        var db = firebase.database();
        var ref = db.ref('games/' + params.game);
        bindDashboardHandlers(ref, function(v) {
          var t = v && v.tournament;
          renderTournamentOverviewFromSnapshot(t, v);
        });
      }
    }, 1000);
  });
}

// Match mode boot (spectator/counter/cocounter)
function bootMatch(params) {
  if (!params.game) {
    console.warn('Match mode requires game ID, redirecting to splash');
    return bootSplash();
  }
  
  // Initialize Firebase (it will read game ID from URL)
  import('./services/firebase.js').then(function(module) {
    module.setupFirebase({});
    
    // Wait for Firebase to be ready, then start match
    setTimeout(function() {
      if (window.firebase && firebase.database) {
        startMatchFlow({ 
          restored: false, // Don't restore from storage when joining via URL
          skipSplash: true, // We already handled splash
          directJoin: true // Joining via shared URL - enable scoring immediately
        });
      } else {
        console.error('Firebase not ready, redirecting to splash');
        showSplash(); // Show splash if Firebase fails
        bootSplash();
      }
    }, 1000);
  }).catch(function(error) {
    console.error('Failed to load Firebase:', error);
    showSplash(); // Show splash if Firebase fails
    bootSplash();
  });
}

// Default splash boot
function bootSplash() {
  const restored = restoreFromStorage();
  if(restored) applyRestoredState();

  if(state.IS_SPECTATOR){
    hideSplash();
    startMatchFlow({ restored: restored });
    return;
  }

  const hasActiveMatch = restored && hasActiveMatchState(state);
  const continueLabel = getContinueLabel(state.playMode);

  setSplashContinueState({
    visible: hasActiveMatch,
    label: continueLabel
  });

  showSplash();
}

document.addEventListener('DOMContentLoaded', boot);


--------------------------------------------------
File End
--------------------------------------------------


js\services\firebase.js
File type: .js
import { state, getDisplayName } from '../state/matchState.js';
import { qs } from '../dom.js';
import { readABFromModalInputs } from '../ui/layout.js';
import { setFirebaseSyncDependencies, bindFirebaseSync } from './firebaseSync.js';
import { LS } from '../constants.js';
import { loadScript } from '../util/loadScript.js';

let pushStateThrottled = function(){};
let pushStateNow = function(){};

// Echo-guard memory
let lastWrite = null;
let firebaseDb = null;
let isLocalOnlyMode = false;

export { pushStateThrottled, pushStateNow };

/**
 * Get Firebase database instance
 * @returns {Object|null} Firebase database or null if not available
 */
export function rtdb() {
  return firebaseDb;
}

/**
 * Get current timestamp
 * @returns {number} Current timestamp
 */
export function nowTs() {
  return Date.now();
}

/**
 * Set last write info for echo-guard
 * @param {Object} writeInfo - Write information {path, ts, hash}
 */
export function setLastWrite(writeInfo) {
  lastWrite = writeInfo;
}

/**
 * Get last write info
 * @returns {Object|null} Last write information
 */
export function getLastWrite() {
  return lastWrite;
}

export async function getStateForSync(includeHostUid = false){
  var names = readABFromModalInputs();
  
  // Convert names to sync format
  const syncNames = { A: getDisplayName(names.A, 'A'), B: getDisplayName(names.B, 'B') };
  
  var base = {
    ts: Date.now(),
    names: syncNames,
    scores: { A: state.scoreA, B: state.scoreB },
    sets: { A: state.setsA, B: state.setsB },
    currentSet: state.currentSet,
    isALeft: document.querySelector('.side.left')?.id === 'sideA',
    online: true,
    format: { discipline: state.matchDiscipline, playMode: state.playMode }
  };
  
  // Include hostUid for new game creation, or preserve existing hostUid
  if (includeHostUid && window.firebase && firebase.auth && firebase.auth().currentUser) {
    // For new game creation: set hostUid to current user
    base.hostUid = firebase.auth().currentUser.uid;
  } else {
    // For regular updates: don't overwrite hostUid (it should remain unchanged)
    // This prevents cocounter from overwriting counter's hostUid
    // hostUid is omitted from regular sync data
  }
  
  // Include currentWriter in sync data to satisfy Firebase rules
  // Get current writer from writeAccess.js
  try {
    const writeAccess = await import('./writeAccess.js');
    base.currentWriter = writeAccess.getCurrentWriter();
  } catch (e) {
    console.warn('[FIREBASE] Failed to get currentWriter:', e);
    base.currentWriter = null; // Fallback
  }
  
  // Add tournament snapshot for dashboard
  var td = state.tournamentData;
  if (td) {
    var tSnap = {
      activeMatchId: td.activeMatchId || null,
      matchStates: td.matchStates || {}
    };
    base.tournament = tSnap;
  }
  
  return base;
}

export function setupFirebase(options){
  options = options || {};
  if(state.IS_SPECTATOR && typeof options.updateScores === 'function'){
    setFirebaseSyncDependencies({ updateScores: options.updateScores });
  }

  loadScript('https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js')
    .then(() => loadScript('https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js'))
    .then(() => loadScript('https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js'))
    .then(afterSDK)
    .catch(err => console.error('Firebase SDK load error:', err));
}

function afterSDK(){
  if(!window.firebase){
    console.warn('Firebase ikke tilgjengelig - lokal modus');
    return;
  }

  var conf = {
    apiKey:'AIzaSyC_ApdJ1Xjldak5lw2myQI-6Y08ncU2UtM',
    authDomain:'badmintonteller.firebaseapp.com',
    projectId:'badmintonteller',
    storageBucket:'badmintonteller.firebasestorage.app',
    messagingSenderId:'776787720081',
    appId:'1:776787720081:web:6802244ed1a94519760c30',
    measurementId:'G-9PK8TF32H2',
    databaseURL:'https://badmintonteller-default-rtdb.europe-west1.firebasedatabase.app/'
  };

  if(!firebase.apps.length) firebase.initializeApp(conf);

  firebase.auth().onAuthStateChanged(async function(user){
    if(!user){
      firebase.auth().signInAnonymously().catch(function(err){
        console.warn('Anon auth feilet', err);
      });
      return;
    }
    
    console.log('[FIREBASE] User authenticated:', user.uid);
    console.log('[FIREBASE] User is anonymous:', user.isAnonymous);

    var db = firebase.database();
    firebaseDb = db; // Store for mutations.js

    if(state.IS_SPECTATOR){
      var gid = qs('game');
      if(!gid){
        alert('Mangler ?game=ID i URL');
        return;
      }
      var ref = db.ref('games/' + gid);
      bindFirebaseSync({ role: 'spectator', ref, canWrite: false });
    }else{
      var gid = ensureGameId();
      var ref = db.ref('games/' + gid);
      var timeout = 0;

      pushStateThrottled = function(){
        clearTimeout(timeout);
        timeout = setTimeout(async function(){
          var dataToSync = await getStateForSync();
          console.log('[FIREBASE DEBUG] Throttled write attempt:', {
            gameId: gid,
            hostUid: dataToSync.hostUid,
            scores: dataToSync.scores,
            currentWriter: dataToSync.currentWriter
          });
          ref.set(dataToSync).then(function() {
            // Clear error state on successful write
            import('./firebaseSync.js').then(function(module) {
              module.clearFirebaseWriteErrors();
            });
          }).catch(function(error) {
            console.warn('[FIREBASE] Throttled push failed:', error);
            // Report error to suppress conflicting reads
            import('./firebaseSync.js').then(function(module) {
              module.reportFirebaseWriteError(error);
            });
          });
        }, 180);
      };

      pushStateNow = async function(){
        clearTimeout(timeout);
        var dataToSync = await getStateForSync();
        console.log('[FIREBASE DEBUG] Attempting to write data:', {
          gameId: gid,
          hostUid: dataToSync.hostUid,
          scores: dataToSync.scores,
          currentWriter: dataToSync.currentWriter
        });
        return ref.set(dataToSync).then(function() {
          // Clear error state on successful write
          import('./firebaseSync.js').then(function(module) {
            module.clearFirebaseWriteErrors();
          });
        }).catch(function(error) {
          console.warn('[FIREBASE] Push now failed:', error);
          // Report error to suppress conflicting reads
          import('./firebaseSync.js').then(function(module) {
            module.reportFirebaseWriteError(error);
          });
          throw error; // Re-throw for caller handling
        });
      };

      // Online status is already included in main game data (getStateForSync)
      // Set disconnect handler only
      db.ref('games/' + gid + '/online').onDisconnect().set(false).catch(function(error) {
        console.warn('[FIREBASE INIT] Failed to set disconnect handler:', error);
        // Don't enable local-only mode for disconnect handler failures
      });
      
      // TODO: Migrate to mutations.js in later PR
      // Guard: Only push initial state if we're the counter (not cocounter/spectator) AND user is authenticated
      if (!state.IS_SPECTATOR && !state.IS_COCOUNTER && user && user.uid) {
        console.log('[FIREBASE INIT] Setting up new game with hostUid:', user.uid);
        
        // Create initial game data with hostUid in one atomic write
        // This satisfies Firebase rules that require hostUid to be set when creating the node
        var initialData = await getStateForSync(true); // Include hostUid for new game creation
        
        // Set initial currentWriter to null - writeAccess.js will manage it separately
        initialData.currentWriter = null;
        
        console.log('[FIREBASE INIT] Creating game with data:', {
          hostUid: initialData.hostUid,
          names: initialData.names,
          scores: initialData.scores,
          currentWriter: initialData.currentWriter
        });
        
        ref.set(initialData).then(function() {
          console.log('[FIREBASE INIT] Initial game data set successfully');
        }).catch(function(error) {
          console.warn('[FIREBASE INIT] Failed to initialize game:', error);
          // If we can't write to this game ID, it might be a permission issue
          // Enable local-only mode until Firebase works
          enableLocalOnlyMode(error);
        });
      }
    }
  });
}

// loadScript moved to js/util/loadScript.js

export function ensureGameId(){
  try{
    var params = new URL(location.href).searchParams;
    var from = params.get('game');
    if(from){
      localStorage.setItem(LS.GAME_ID, from);
      return from;
    }
    var cur = localStorage.getItem(LS.GAME_ID);
    if(cur) return cur;
    var g = makeId(9);
    localStorage.setItem(LS.GAME_ID, g);
    return g;
  }catch(_){
    return 'LOCALTEST';
  }
}

/**
 * Generate a new game ID and store it (for new matches)
 */
export function generateNewGameId(){
  try{
    var g = makeId(9);
    localStorage.setItem(LS.GAME_ID, g);
    console.log('[FIREBASE] Generated new game ID:', g);
    return g;
  }catch(_){
    return 'LOCALTEST';
  }
}

/**
 * Get Firebase reference for a specific game
 * @param {string} gameId - Game ID to get reference for
 * @returns {Object|null} Firebase reference or null if not available
 */
export function getGameRef(gameId){
  var db = rtdb();
  if (!db) return null;
  var gid = gameId || ensureGameId();
  return gid ? db.ref('games/' + gid) : null;
}

/**
 * Get Firebase reference for current game
 * @returns {Object|null} Firebase reference for current game or null
 */
export function currentGameRef(){
  return getGameRef(ensureGameId());
}

export function spectatorShareUrl(){
  var gid = ensureGameId();
  try{
    var u = new URL(location.href);
    u.searchParams.set('mode', 'spectator');
    u.searchParams.set('game', gid);
    return u.toString();
  }catch(_){
    return location.origin + location.pathname + '?mode=spectator&game=' + encodeURIComponent(gid);
  }
}

// Generate share URL for any mode
export function generateShareUrl(mode, gameId) {
  mode = mode || 'spectator';
  gameId = gameId || ensureGameId();
  
  try {
    var u = new URL(location.href);
    u.searchParams.set('mode', mode);
    u.searchParams.set('game', gameId);
    return u.toString();
  } catch(_) {
    return location.origin + location.pathname + '?mode=' + encodeURIComponent(mode) + '&game=' + encodeURIComponent(gameId);
  }
}

/**
 * Enable local-only mode when Firebase permissions fail
 */
function enableLocalOnlyMode(error) {
  if (isLocalOnlyMode) return; // Already enabled
  
  isLocalOnlyMode = true;
  window._badmintonLocalOnlyMode = true; // Global flag for other modules
  console.warn('[FIREBASE] Enabling local-only mode due to permission error:', error);
  
  // Replace push functions with no-ops
  pushStateThrottled = function() {
    console.log('[FIREBASE] Skipping throttled push (local-only mode)');
  };
  
  pushStateNow = function() {
    console.log('[FIREBASE] Skipping immediate push (local-only mode)');
    return Promise.resolve(); // Return resolved promise for compatibility
  };
  
  // Show user notification
  import('../dom.js').then(function(module) {
    module.toast('Lokal modus: Poeng lagres kun på denne enheten');
  });
  
  // Disable Firebase sync to prevent conflicting reads
  import('./firebaseSync.js').then(function(module) {
    module.unbindFirebaseSync();
  });
}

function makeId(n){
  n = n || 9;
  var alphabet = 'ABCDEFGHJKLMNPQRSTUVXYZ23456789';
  var out = '';
  for(var i=0;i<n;i++) out += alphabet[(Math.random() * alphabet.length) | 0];
  return out;
}

export function bindDashboardHandlers(ref, cb){
  ref.on('value', function(snap){
    var v = snap && snap.val ? snap.val() : null;
    try { 
      cb && cb(v || {}); 
    } catch(e){
      console.warn('Dashboard handler error:', e);
    }
  });
}



--------------------------------------------------
File End
--------------------------------------------------


js\services\firebaseSync.js
File type: .js
// Firebase sync for alle roller - konsoliderer spectator.js + counterRead.js
import { state, getDisplayName } from '../state/matchState.js';
import { updateCurrentWriter } from './writeAccess.js';

// Firebase binding state
let _boundRef = null;
let _onValue = null;
let _currentRole = null;
let _writeErrorCount = 0; // Track consecutive write errors
let _suppressReadsUntil = 0; // Suppress reads after write errors

// Previous values for change detection
const prev = {
  scoreA: null,
  scoreB: null,
  setsA: null,
  setsB: null,
  isALeft: null
};

// Swap state to prevent loops (from counterRead.js)
let _swapInProgress = false;

// Spectator-specific state (from spectator.js)
let isSwapping = false;
let pendingZero = false;

// Injected UI callbacks (dependency injection pattern)
let _updateScores = function(){};
let _fitScores = function(){};
let _handleScoreBump = function(){};
let _clearWinner = function(){};
let _getSuppressUntil = function(){};
let _startVisualSwap = function(){};
let _setSidesDomTo = function(){};

/**
 * Set dependencies for UI callbacks
 * Replaces: setSpectatorDependencies + setCounterReadDependencies
 */
export function setFirebaseSyncDependencies(deps){
  deps = deps || {};
  if (typeof deps.updateScores === 'function') _updateScores = deps.updateScores;
  if (typeof deps.fitScores === 'function') _fitScores = deps.fitScores;
  if (typeof deps.handleScoreBump === 'function') _handleScoreBump = deps.handleScoreBump;
  if (typeof deps.clearWinner === 'function') _clearWinner = deps.clearWinner;
  if (typeof deps.getSuppressUntil === 'function') _getSuppressUntil = deps.getSuppressUntil;
  if (typeof deps.startVisualSwap === 'function') _startVisualSwap = deps.startVisualSwap;
  if (typeof deps.setSidesDomTo === 'function') _setSidesDomTo = deps.setSidesDomTo;
}

/**
 * Unbind Firebase listeners
 * Replaces: unbindCounterRead + spectator cleanup
 */
export function unbindFirebaseSync(){
  try {
    if (_boundRef && _onValue) _boundRef.off('value', _onValue);
  } catch (e) {}
  _boundRef = null;
  _onValue = null;
  _currentRole = null;
}

/**
 * Report Firebase write error to suppress conflicting reads
 */
export function reportFirebaseWriteError(error) {
  _writeErrorCount++;
  console.warn('[FIREBASE SYNC] Write error reported:', error, 'Count:', _writeErrorCount);
  
  // Suppress reads for increasing duration based on error count
  var suppressDuration = Math.min(_writeErrorCount * 1000, 10000); // Max 10 seconds
  _suppressReadsUntil = Date.now() + suppressDuration;
  
  console.log('[FIREBASE SYNC] Suppressing reads for', suppressDuration, 'ms');
}

/**
 * Clear write error state (call when write succeeds)
 */
export function clearFirebaseWriteErrors() {
  if (_writeErrorCount > 0) {
    console.log('[FIREBASE SYNC] Clearing write error state');
    _writeErrorCount = 0;
    _suppressReadsUntil = 0;
  }
}

/**
 * Set name chips directly (utility from spectator.js)
 */
export function setNameChipsDirect(nameA, nameB){
  var ca = document.getElementById('nameA_chip');
  var cb = document.getElementById('nameB_chip');
  
  // Handle both string and object formats
  const aDisplay = getDisplayName(nameA, 'A');
  const bDisplay = getDisplayName(nameB, 'B');
  
  if(ca) ca.textContent = aDisplay;
  if(cb) cb.textContent = bDisplay;
}

// Note: startVisualSwapSpectator removed - using injected _startVisualSwap instead

/**
 * Main Firebase sync function
 * Replaces: bindSpectatorHandlers + bindCounterReadHandlers
 * 
 * Roles:
 * - spectator: Read-only viewer
 * - counter: Active teller with write access
 * - cocounter: Medteller (same as counter but without current write access)
 */
export function bindFirebaseSync(options){
  const { role, ref, canWrite = false } = options;
  
  unbindFirebaseSync(); // Ensure clean binding
  if (!ref) return function(){};
  
  _boundRef = ref;
  _currentRole = role;
  
  _onValue = function(snap){
    var v = snap && snap.val ? snap.val() : null;
    if (!v) return;
    
    // Suppress reads if we're having write permission issues
    if (_suppressReadsUntil > Date.now()) {
      console.log('[FIREBASE READ] Suppressing read due to recent write errors');
      return;
    }
    
    // Debug logging for counter role
    if (role === 'counter') {
      console.log('[FIREBASE READ] Received data:', {
        scores: v.scores, sets: v.sets, currentSet: v.currentSet
      });
    }
    
    // Extract values
    var nextIsALeft = !!v.isALeft;
    var a = Number(v.scores?.A || 0);
    var b = Number(v.scores?.B || 0);
    var setsA = Number(v.sets?.A || 0);
    var setsB = Number(v.sets?.B || 0);
    
    // Store previous values for bump detection (counter role)
    var prevScoreA = prev.scoreA;
    var prevScoreB = prev.scoreB;
    
    // Spectator-specific logic for set changes and zero drops
    if (role === 'spectator') {
      var isSetChange = (prev.setsA != null && (prev.setsA !== setsA || prev.setsB !== setsB));
      var dropToZero = (a === 0 && b === 0) && ((prev.scoreA > 0) || (prev.scoreB > 0));
      var wantSwap = (prev.isALeft !== null) && (prev.isALeft !== nextIsALeft);

      if(dropToZero && (wantSwap || isSwapping)){
        pendingZero = true;
        a = typeof prev.scoreA === 'number' ? prev.scoreA : a;
        b = typeof prev.scoreB === 'number' ? prev.scoreB : b;
      }
    }
    
    // Update state
    state.scoreA = a;
    state.scoreB = b;
    state.setsA = setsA;
    state.setsB = setsB;
    state.currentSet = Number(v.currentSet || state.currentSet);
    state.isALeft = nextIsALeft;
    
    // Update names
    if (v.names) {
      state.nameA = v.names.A;
      state.nameB = v.names.B;
    }
    if (v.format) state.format = v.format;
    if (typeof v.msg !== 'undefined') state.msg = v.msg;
    
    // Update current writer (for counter/cocounter roles)
    // Skip in local-only mode to prevent incorrect write access assignment
    if (typeof v.currentWriter !== 'undefined' && (role === 'counter' || role === 'cocounter') && !window._badmintonLocalOnlyMode) {
      updateCurrentWriter(v.currentWriter);
    }
    
    // Set name chips
    setNameChipsDirect(v.names?.A, v.names?.B);
    
    // Handle side swapping
    if(prev.isALeft === null){
      // First load - set DOM to match state
      try { _setSidesDomTo(nextIsALeft); } catch(_){}
    } else if(prev.isALeft !== nextIsALeft){
      // Side swap detected
      if (role === 'spectator') {
        try { _startVisualSwap(); } catch(_){}
      } else if ((role === 'counter' || role === 'cocounter') && !_swapInProgress) {
        // Counter role: use disable/enable pattern to prevent loops
        console.log('[SWAP DEBUG] Side swap detected - executing with disable/enable pattern');
        _swapInProgress = true;
        
        // Temporarily disable Firebase reads during swap
        unbindFirebaseSync();
        
        try { 
          _startVisualSwap(() => {
            // Re-enable Firebase reads AFTER swap animation AND score reset is complete
            console.log('[SWAP DEBUG] Re-enabling Firebase reads after swap completion');
            _swapInProgress = false;
            // Note: Rebinding should be handled by calling code
          });
        } catch(error) {
          console.warn('[SWAP DEBUG] Swap failed, re-enabling reads:', error);
          _swapInProgress = false;
          // Don't rebind on error to avoid loops
        }
      }
    }
    
    // Update UI
    _updateScores();
    
    // Get DOM elements (used by both roles)
    var elA = document.getElementById('A_digits');
    var elB = document.getElementById('B_digits');
    
    // Handle bump effects (role-specific logic)
    if ((role === 'counter' || role === 'cocounter') && canWrite) {
      // Counter/CoCounter with write access: Check for score changes and trigger bumps (with suppression)
      if (prevScoreA !== null && prevScoreA !== state.scoreA) {
        var suppressUntil = _getSuppressUntil('A');
        if (suppressUntil && Date.now() < suppressUntil) {
          console.log('[FIREBASE DEBUG] Player A bump suppressed due to recent local action');
        } else {
          console.log('[FIREBASE DEBUG] Player A score changed, triggering bump');
          try { _handleScoreBump(prevScoreA, state.scoreA, elA); } catch(_){}
        }
      }
      
      if (prevScoreB !== null && prevScoreB !== state.scoreB) {
        var suppressUntil = _getSuppressUntil('B');
        if (suppressUntil && Date.now() < suppressUntil) {
          console.log('[FIREBASE DEBUG] Player B bump suppressed due to recent local action');
        } else {
          console.log('[FIREBASE DEBUG] Player B score changed, triggering bump');
          try { _handleScoreBump(prevScoreB, state.scoreB, elB); } catch(_){}
        }
      }
    } else if (role === 'counter' || role === 'cocounter') {
      // Counter/CoCounter without write access: Show bumps from Firebase changes (no suppression)
      if (prevScoreA !== null && prevScoreA !== state.scoreA) {
        try { _handleScoreBump(prevScoreA, state.scoreA, elA); } catch(_){}
      }
      if (prevScoreB !== null && prevScoreB !== state.scoreB) {
        try { _handleScoreBump(prevScoreB, state.scoreB, elB); } catch(_){}
      }
    } else if (role === 'spectator') {
      // Spectator: Handle bump effects with suppression logic
      try{ _fitScores(); }catch(_){}
      
      var isSetChange = (prev.setsA != null && (prev.setsA !== setsA || prev.setsB !== setsB));
      var dropToZero = (a === 0 && b === 0) && ((prev.scoreA > 0) || (prev.scoreB > 0));
      var suppressBumps = isSetChange || dropToZero;

      if(!suppressBumps && prevScoreA !== null && prevScoreB !== null){
        try { _handleScoreBump(prevScoreA, a, elA); } catch(_){}
        try { _handleScoreBump(prevScoreB, b, elB); } catch(_){}
      }else{
        elA?.classList.remove('pop','popMinus');
        elB?.classList.remove('pop','popMinus');
      }
      
      // Queue fit for layout changes
      if(prev.isALeft === null || prev.isALeft !== nextIsALeft) try{ _fitScores(); }catch(_){}
      if(prev.setsA != null && (prev.setsA !== setsA || prev.setsB !== setsB)) try{ _fitScores(); }catch(_){}
    }
    
    // Winner highlighting (shared by both roles)
    try { 
      _clearWinner();
      
      // Mark winner based on sets (best of three)
      var finished = (setsA >= 2) || (setsB >= 2);
      if (finished) {
        if (setsA > setsB) {
          var sa = document.getElementById('scoreA');
          var na = document.getElementById('nameA_chip');
          if (sa) sa.classList.add('winner');
          if (na) na.classList.add('winnerName');
        } else if (setsB > setsA) {
          var sb = document.getElementById('scoreB');
          var nb = document.getElementById('nameB_chip');
          if (sb) sb.classList.add('winner');
          if (nb) nb.classList.add('winnerName');
        }
      }
    } catch(_){}
    
    // Update previous values for next comparison
    prev.scoreA = state.scoreA;
    prev.scoreB = state.scoreB;
    prev.setsA = state.setsA;
    prev.setsB = state.setsB;
    prev.isALeft = nextIsALeft;
  };
  
  // Bind Firebase listener
  if (role === 'spectator') {
    ref.off(); // Clean slate for spectator
  }
  ref.on('value', _onValue);
  
  return unbindFirebaseSync;
}

// Legacy function removed - spectator.js fully replaced


--------------------------------------------------
File End
--------------------------------------------------


js\services\mutations.js
File type: .js
import { rtdb, nowTs, getLastWrite, setLastWrite } from './firebase.js';

/**
 * Centralized mutation helpers for RTDB writes
 * All writes should go through these functions to avoid echo-loops and enable future role-gating
 */

/**
 * Safe push to RTDB with echo-guard and metadata
 * @param {string} refPath - Firebase reference path
 * @param {Object} payload - Data to write
 * @returns {Promise} Firebase write promise
 */
export function safePush(refPath, payload) {
  if (!refPath || !payload) {
    return Promise.reject(new Error('safePush: refPath and payload required'));
  }
  
  var db = rtdb();
  if (!db) {
    return Promise.reject(new Error('safePush: Firebase not available'));
  }
  
  var ref = db.ref(refPath);
  var ts = nowTs();
  
  // Calculate hash for echo-guard
  var hash = calculateHash(JSON.stringify(payload) + refPath);
  
  // Add metadata
  var dataWithMeta = Object.assign({}, payload, {
    _ts: ts,
    _hash: hash
  });
  
  // Store lastWrite for echo-guard
  setLastWrite({
    path: refPath,
    ts: ts,
    hash: hash
  });
  
  return ref.set(dataWithMeta);
}

/**
 * Set a specific field in RTDB
 * @param {string} refPath - Firebase reference path
 * @param {string} field - Field name to set
 * @param {*} value - Value to set
 * @returns {Promise} Firebase write promise
 */
export function setField(refPath, field, value) {
  if (!refPath || !field) {
    return Promise.reject(new Error('setField: refPath and field required'));
  }
  
  var db = rtdb();
  if (!db) {
    return Promise.reject(new Error('setField: Firebase not available'));
  }
  
  var ref = db.ref(refPath + '/' + field);
  var ts = nowTs();
  
  // Calculate hash for echo-guard
  var hash = calculateHash(JSON.stringify(value) + refPath + '/' + field);
  
  // Add metadata
  var dataWithMeta = {
    _ts: ts,
    _hash: hash,
    value: value
  };
  
  // Store lastWrite for echo-guard
  setLastWrite({
    path: refPath + '/' + field,
    ts: ts,
    hash: hash
  });
  
  return ref.set(dataWithMeta);
}

/**
 * Append an event to a list in RTDB
 * @param {string} refPath - Firebase reference path
 * @param {Object} event - Event data to append
 * @returns {Promise} Firebase write promise
 */
export function appendEvent(refPath, event) {
  if (!refPath || !event) {
    return Promise.reject(new Error('appendEvent: refPath and event required'));
  }
  
  var db = rtdb();
  if (!db) {
    return Promise.reject(new Error('appendEvent: Firebase not available'));
  }
  
  var ref = db.ref(refPath);
  var ts = nowTs();
  
  // Add metadata to event
  var eventWithMeta = Object.assign({}, event, {
    _ts: ts,
    _hash: calculateHash(JSON.stringify(event) + refPath + '/append')
  });
  
  // Store lastWrite for echo-guard
  setLastWrite({
    path: refPath + '/append',
    ts: ts,
    hash: eventWithMeta._hash
  });
  
  return ref.push(eventWithMeta);
}

/**
 * Calculate simple hash for echo-guard
 * @param {string} input - String to hash
 * @returns {string} Simple hash
 */
function calculateHash(input) {
  var hash = 0;
  if (input.length === 0) return hash.toString();
  
  for (var i = 0; i < input.length; i++) {
    var char = input.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash; // Convert to 32bit integer
  }
  
  return Math.abs(hash).toString(36);
}

/**
 * Check if a snapshot is an echo of our last write
 * @param {Object} snapshot - Firebase snapshot
 * @returns {boolean} True if this is an echo
 */
export function isEcho(snapshot) {
  var lastWrite = getLastWrite();
  if (!snapshot || !lastWrite) {
    return false;
  }
  
  var data = snapshot.val();
  if (!data || !data._ts || !data._hash) {
    return false;
  }
  
  // Check if this matches our last write
  return data._ts === lastWrite.ts && 
         data._hash === lastWrite.hash;
}


--------------------------------------------------
File End
--------------------------------------------------


js\services\namesStore.js
File type: .js
// js/services/namesStore.js
import { pushPrev } from './storage.js';

export function saveIndividual(name){
  if(!name) return;
  const n = String(name).trim();
  if(!n) return;
  // (Ingen filter på " / " her – både enkelt- og lagnavn kan lagres.
  // Filtrering skjer der vi leser ut kandidatene.)
  pushPrev(n);
}

export function saveFromAB(names, discipline){
  if(!names) return;
  // Singel: names.A og names.B er strenger
  if(discipline === 'single' || !discipline){
    if(typeof names.A === 'string') saveIndividual(names.A);
    if(typeof names.B === 'string') saveIndividual(names.B);
    return;
  }
  // Dobbel: names.{A,B}.players = [p1, p2]
  if(discipline === 'double'){
    if(names.A && Array.isArray(names.A.players)){
      names.A.players.forEach(saveIndividual);
    }
    if(names.B && Array.isArray(names.B.players)){
      names.B.players.forEach(saveIndividual);
    }
  }
}

export function bindNameInput(input){
  if(!input) return;
  // Save name when user types manually
  input.addEventListener('blur', function(){
    const name = this.value.trim();
    if(name && name.length > 0){
      saveIndividual(name);
    }
  });
}


--------------------------------------------------
File End
--------------------------------------------------


js\services\storage.js
File type: .js
import { LS } from '../constants.js';

export function loadMatches(){
  try{
    const raw = localStorage.getItem(LS.MATCHES);
    return raw ? JSON.parse(raw) : [];
  }catch(_){
    return [];
  }
}

export function saveMatches(list){
  try{
    localStorage.setItem(LS.MATCHES, JSON.stringify(list));
  }catch(_){ }
}

export function saveLastNames(a,b){
  try{
    localStorage.setItem(LS.LAST, JSON.stringify([a,b]));
  }catch(_){ }
  pushPrev(a);
  pushPrev(b);
}

export function loadLastNames(){
  const defaults = ['Spiller A', 'Spiller B'];

  function toTrimmed(value){
    if(value === undefined || value === null) return '';
    return value.toString().trim();
  }

  function coerceEntry(entry, fallback){
    if(entry === undefined || entry === null) return fallback;

    if(typeof entry === 'string' || typeof entry === 'number' || typeof entry === 'boolean'){
      const str = toTrimmed(entry);
      return str || fallback;
    }

    if(Array.isArray(entry)){
      const joined = entry.map(toTrimmed).filter(Boolean).join(' / ');
      return joined || fallback;
    }

    if(typeof entry === 'object'){
      if(typeof entry.display === 'string' && entry.display.trim()){
        return entry.display.trim();
      }
      if(typeof entry.teamName === 'string' && entry.teamName.trim()){
        return entry.teamName.trim();
      }

      var players = [];
      if(Array.isArray(entry.players)){
        players = entry.players.slice();
      }else if(entry.players && typeof entry.players === 'object'){
        if(Object.prototype.hasOwnProperty.call(entry.players, 'p1')) players.push(entry.players.p1);
        if(Object.prototype.hasOwnProperty.call(entry.players, 'p2')) players.push(entry.players.p2);
        if(Object.prototype.hasOwnProperty.call(entry.players, 'p3')) players.push(entry.players.p3);
      }else if(Array.isArray(entry.names)){
        players = entry.names.slice();
      }

      if(players.length){
        const joinedPlayers = players.map(toTrimmed).filter(Boolean).join(' / ');
        if(joinedPlayers) return joinedPlayers;
      }
    }

    return fallback;
  }

  function readEntry(data, index){
    if(Array.isArray(data)){
      return data[index];
    }
    if(!data || typeof data !== 'object') return null;

    const side = index === 0 ? 'A' : 'B';
    const keys = [
      side,
      side.toLowerCase(),
      String(index),
      index === 0 ? 'left' : 'right',
      index === 0 ? 'teamA' : 'teamB'
    ];

    for(var i = 0; i < keys.length; i++){
      var key = keys[i];
      if(Object.prototype.hasOwnProperty.call(data, key)) return data[key];
    }

    return null;
  }

  try{
    const raw = localStorage.getItem(LS.LAST);
    if(!raw) return null;

    const parsed = JSON.parse(raw);
    const values = [readEntry(parsed, 0), readEntry(parsed, 1)];

    let hasStoredValue = false;
    const normalized = defaults.map(function(fallback, index){
      const value = values[index];
      if(value !== undefined && value !== null) hasStoredValue = true;
      return coerceEntry(value, fallback);
    });

    return hasStoredValue ? normalized : null;
  }catch(_){
    return null;
  }
}

export function getPrevNames(){
  try{
    const arr = JSON.parse(localStorage.getItem(LS.PREV) || '[]');
    return Array.isArray(arr) ? arr : [];
  }catch(_){
    return [];
  }
}

export function setPrevNames(arr){
  try{
    localStorage.setItem(LS.PREV, JSON.stringify(arr.slice(0,100)));
  }catch(_){ }
}

export function pushPrev(name){
  // Handle both string and object formats
  const nameStr = typeof name === 'string' ? name : (name?.display || name?.teamName || '');
  const trimmed = (nameStr || '').trim();
  if(!trimmed) return;
  
  // Don't save team names (names containing " / ") to autocomplete
  if(trimmed.includes(' / ')) return;
  
  const arr = getPrevNames().filter(function(x){ return x !== trimmed; });
  arr.unshift(trimmed);
  setPrevNames(arr);
}

export function getRecentNames(limit){
  const arr = getPrevNames();
  return arr.slice(0, limit || 6);
}


--------------------------------------------------
File End
--------------------------------------------------


js\services\tournament.js
File type: .js
/**
 * Tournament service functions
 */

/**
 * Generate Swiss tournament Round 1 matches with placeholder rounds
 * @param {Array} participants - Array of participant names
 * @returns {Object} Object with round1 and placeholderRounds
 */
export function generateSwissRoundOne(participants) {
  if (!participants || participants.length < 2) {
    return { round1: [], placeholderRounds: [] };
  }

  // Filter out empty strings
  const validParticipants = participants.filter(name => name && name.trim().length > 0);
  
  if (validParticipants.length < 2) {
    return { round1: [], placeholderRounds: [] };
  }

  const round1 = [];
  
  // Pair participants in order (0-1, 2-3, ...)
  for (let i = 0; i < validParticipants.length; i += 2) {
    const playerA = validParticipants[i];
    const playerB = (i + 1 < validParticipants.length) ? validParticipants[i + 1] : null;
    
    round1.push({
      id: `match-${round1.length + 1}`,
      round: 1,
      playerA: playerA,
      playerB: playerB
    });
  }

  // Store Round 1 match IDs for reference
  const roundOneIds = round1.map(match => match.id);
  
  // Generate placeholder rounds
  const placeholderRounds = [];
  
  // Round 2: Winners vs Winners, Losers vs Losers
  const round2Matches = [];
  
  // Process winners bracket
  const winnersCount = round1.length;
  for (let i = 0; i < winnersCount; i += 2) {
    if (i + 1 < winnersCount) {
      // Normal pairing
      round2Matches.push({
        id: `match-${round1.length + round2Matches.length + 1}`,
        round: 2,
        playerA: `Vinner kamp ${roundOneIds[i]}`,
        playerB: `Vinner kamp ${roundOneIds[i + 1]}`
      });
    } else {
      // Odd number - last player gets walkover
      round2Matches.push({
        id: `match-${round1.length + round2Matches.length + 1}`,
        round: 2,
        playerA: `Vinner kamp ${roundOneIds[i]}`,
        playerB: 'Walkover'
      });
    }
  }
  
  // Process losers bracket
  for (let i = 0; i < winnersCount; i += 2) {
    if (i + 1 < winnersCount) {
      // Normal pairing
      round2Matches.push({
        id: `match-${round1.length + round2Matches.length + 1}`,
        round: 2,
        playerA: `Taper kamp ${roundOneIds[i]}`,
        playerB: `Taper kamp ${roundOneIds[i + 1]}`
      });
    } else {
      // Odd number - last player gets walkover
      round2Matches.push({
        id: `match-${round1.length + round2Matches.length + 1}`,
        round: 2,
        playerA: `Taper kamp ${roundOneIds[i]}`,
        playerB: 'Walkover'
      });
    }
  }
  
  // Round 3: Final matches
  const round3Matches = [];
  if (round2Matches.length >= 2) {
    round3Matches.push({
      id: `match-${round1.length + round2Matches.length + 1}`,
      round: 3,
      playerA: `Vinner kamp ${round2Matches[0].id}`,
      playerB: `Vinner kamp ${round2Matches[1].id}`
    });
    
    if (round2Matches.length >= 4) {
      round3Matches.push({
        id: `match-${round1.length + round2Matches.length + 2}`,
        round: 3,
        playerA: `Vinner kamp ${round2Matches[2].id}`,
        playerB: `Vinner kamp ${round2Matches[3].id}`
      });
    }
  }

  placeholderRounds.push(...round2Matches, ...round3Matches);

  return { round1, placeholderRounds };
}

--------------------------------------------------
File End
--------------------------------------------------


js\services\writeAccess.js
File type: .js
// Dynamic write access management for counter/cocounter roles
import { state } from '../state/matchState.js';

// Current write access state (synced via Firebase)
let _currentWriter = null; // 'counter' | 'cocounter' | null
let _explicitlyReleased = false; // Track if write access was explicitly released
let _onWriteAccessChange = function(){};
let _pushStateNow = function(){};
let _getGameRef = function(){ return null; };

/**
 * Set callback for write access changes
 */
export function setWriteAccessDependencies(deps){
  deps = deps || {};
  if (typeof deps.onWriteAccessChange === 'function') {
    _onWriteAccessChange = deps.onWriteAccessChange;
  }
  if (typeof deps.pushStateNow === 'function') {
    _pushStateNow = deps.pushStateNow;
  }
  if (typeof deps.getGameRef === 'function') {
    _getGameRef = deps.getGameRef;
  }
}

/**
 * Get current writer role
 */
export function getCurrentWriter(){
  return _currentWriter;
}

/**
 * Check if current user has write access
 * Note: This is different from state.allowScoring:
 * - allowScoring = workflow state (setup vs active match)
 * - hasWriteAccess = security (who can modify scores right now)
 */
export function hasWriteAccess(){
  if (state.IS_SPECTATOR) return false;
  
  // In local-only mode, use the same logic as normal mode
  // but without Firebase sync (This is set when Firebase permissions fail)
  if (window._badmintonLocalOnlyMode) {
    // Use same logic as normal mode for consistency
    if (_currentWriter === null) {
      if (_explicitlyReleased) {
        return false; // No one has access after explicit release
      }
      return !state.IS_COCOUNTER; // Counter gets default access on startup
    }
    
    // Check if current user matches the writer
    const currentRole = state.IS_COCOUNTER ? 'cocounter' : 'counter';
    return _currentWriter === currentRole;
  }
  
  // If no writer is set, counter gets default access
  // UNLESS write access was explicitly released
  if (_currentWriter === null) {
    if (_explicitlyReleased) {
      return false; // No one has access after explicit release
    }
    return !state.IS_COCOUNTER; // Counter gets default access on startup
  }
  
  // Check if current user matches the writer
  if (state.IS_COCOUNTER) {
    return _currentWriter === 'cocounter';
  } else {
    return _currentWriter === 'counter';
  }
}

/**
 * Claim write access for current user
 */
export function claimWriteAccess(){
  if (state.IS_SPECTATOR) return false;
  
  var newWriter = state.IS_COCOUNTER ? 'cocounter' : 'counter';
  
  console.log('[WRITE ACCESS] Claiming write access for:', newWriter);
  console.log('[WRITE ACCESS] Current writer state:', _currentWriter);
  console.log('[WRITE ACCESS] _getGameRef function:', typeof _getGameRef);
  
  // Update Firebase with new writer
  try {
    var ref = _getGameRef();
    console.log('[WRITE ACCESS] Firebase ref:', !!ref);
    if (ref) {
      ref.child('currentWriter').set(newWriter).then(function() {
        console.log('[WRITE ACCESS] Successfully updated Firebase currentWriter to:', newWriter);
        // Clear explicitly released flag when someone claims access
        _explicitlyReleased = false;
      }).catch(function(error) {
        console.warn('[WRITE ACCESS] Failed to set currentWriter:', error);
      });
    } else {
      console.warn('[WRITE ACCESS] No Firebase ref available - Firebase may not be ready');
      return false;
    }
  } catch(error) {
    console.warn('[WRITE ACCESS] Failed to update Firebase:', error);
    return false;
  }
  
  return true;
}

/**
 * Release write access
 */
export function releaseWriteAccess(){
  if (state.IS_SPECTATOR) return false;
  
  var currentRole = state.IS_COCOUNTER ? 'cocounter' : 'counter';
  
  console.log('[WRITE ACCESS] Attempting to release write access');
  console.log('[WRITE ACCESS] Current role:', currentRole);
  console.log('[WRITE ACCESS] Current writer:', _currentWriter);
  console.log('[WRITE ACCESS] Has access check:', _currentWriter === currentRole);
  
  // Allow counter to release even default access, cocounter can only release if they have explicit access
  var canRelease = (_currentWriter === currentRole) || 
                   (currentRole === 'counter' && _currentWriter === null && !_explicitlyReleased);
  
  if (canRelease) {
    console.log('[WRITE ACCESS] Releasing write access from:', currentRole, '(current writer:', _currentWriter, ')');
    
    // Update Firebase to remove current writer
    try {
      var ref = _getGameRef();
      if (ref) {
        ref.child('currentWriter').set(null).then(function() {
          console.log('[WRITE ACCESS] Successfully cleared Firebase currentWriter');
        }).catch(function(error) {
          console.warn('[WRITE ACCESS] Failed to clear currentWriter:', error);
        });
      } else {
        console.warn('[WRITE ACCESS] No Firebase ref available for release');
        // Still allow release in local-only mode
      }
    } catch(error) {
      console.warn('[WRITE ACCESS] Failed to clear Firebase:', error);
      // Still allow release even if Firebase fails
    }
    
    // Mark as explicitly released and clear local writer state
    var previousWriter = _currentWriter;
    _explicitlyReleased = true;
    _currentWriter = null; // Update local state immediately
    console.log('[WRITE ACCESS] Write access explicitly released - no one has access now');
    
    // Notify about the change immediately (don't wait for Firebase)
    try {
      _onWriteAccessChange({
        writer: _currentWriter,
        hasAccess: hasWriteAccess(),
        previousWriter: previousWriter
      });
    } catch(e) {
      console.warn('[WRITE ACCESS] Failed to notify access change:', e);
    }
    
    return true;
  }
  
  console.log('[WRITE ACCESS] Cannot release - user does not have write access');
  return false; // Didn't have access
}

/**
 * Initialize write access system
 */
export function initWriteAccess(){
  console.log('[WRITE ACCESS] initWriteAccess called');
  console.log('[WRITE ACCESS] state.IS_SPECTATOR:', state.IS_SPECTATOR);
  console.log('[WRITE ACCESS] state.IS_COCOUNTER:', state.IS_COCOUNTER);
  console.log('[WRITE ACCESS] _getGameRef function:', typeof _getGameRef);
  
  // Counter gets default write access, cocounter does not
  if (!state.IS_SPECTATOR && !state.IS_COCOUNTER) {
    console.log('[WRITE ACCESS] Initializing as counter - setting Firebase currentWriter');
    
    // Set initial writer in Firebase
    try {
      var ref = _getGameRef();
      console.log('[WRITE ACCESS] Firebase ref for init:', ref);
      if (ref) {
        // Only set if not already set (to avoid overriding existing writer)
        ref.child('currentWriter').once('value', function(snapshot) {
          if (!snapshot.exists()) {
            ref.child('currentWriter').set('counter');
            console.log('[WRITE ACCESS] Set initial Firebase currentWriter to counter');
          } else {
            console.log('[WRITE ACCESS] Firebase currentWriter already exists:', snapshot.val());
          }
        });
      } else {
        console.warn('[WRITE ACCESS] No Firebase ref available for initialization');
      }
    } catch(error) {
      console.warn('[WRITE ACCESS] Failed to initialize Firebase currentWriter:', error);
    }
  } else {
    console.log('[WRITE ACCESS] Initialized as cocounter/spectator - no default writer set');
  }
}

/**
 * Update current writer from Firebase
 * Called by firebaseSync when currentWriter changes
 */
export function updateCurrentWriter(newWriter){
  var previousWriter = _currentWriter;
  
  // ELEGANT: Only update if value actually changed (prevent infinite loops)
  if (previousWriter === newWriter) {
    console.log('[WRITE ACCESS] Firebase update - currentWriter unchanged:', newWriter, '(skipping)');
    return;
  }
  
  _currentWriter = newWriter;
  
  console.log('[WRITE ACCESS] Firebase update - currentWriter changed from', previousWriter, 'to', newWriter);
  
  // Notify about the change
  try {
    _onWriteAccessChange({
      writer: _currentWriter,
      hasAccess: hasWriteAccess(),
      previousWriter: previousWriter
    });
  } catch(_){}
}

/**
 * Get write access status for UI
 */
export function getWriteAccessStatus(){
  return {
    currentWriter: _currentWriter,
    hasAccess: hasWriteAccess(),
    canClaim: !state.IS_SPECTATOR && !hasWriteAccess(),
    canRelease: !state.IS_SPECTATOR && hasWriteAccess()
  };
}


--------------------------------------------------
File End
--------------------------------------------------


js\state\matchState.js
File type: .js
import { LS } from '../constants.js';
import { qs } from '../dom.js';

const MODE = (qs('mode') || 'counter').toLowerCase();

export const state = {
  scoreA: 0,
  scoreB: 0,
  setsA: 0,
  setsB: 0,
  target: 21,
  cap: 30,
  currentSet: 1,
  swappedAt11: false,
  locked: false,
  swapping: false,
  betweenSets: false,
  pendingSetWinner: null,
  setHistory: [],
  allowScoring: false, // Workflow: false = setup/name-editing, true = active match
  role: 'writer', // TODO: Implement proper role-gating in later PR
  nameEditMode: false,
  matchDiscipline: 'single',
  playMode: 'singleMatch',
  VIEW_MODE: 'match',
  IS_SPECTATOR: MODE === 'spectator',
  IS_COUNTER: MODE === 'counter' || MODE === 'cocounter',
  IS_COCOUNTER: MODE === 'cocounter',
  tournamentData: { name: '', participants: [], matches: [], locked: false },
  ui: { nextNavHint: null }
};

const DEFAULT_NAMES = {
  single: {
    A: { players: ['Spiller A'], display: 'Spiller A' },
    B: { players: ['Spiller B'], display: 'Spiller B' }
  },
  double: {
    A: { players: ['Spiller A', 'Spiller A2'], display: 'Spiller A / Spiller A2', teamName: '' },
    B: { players: ['Spiller B', 'Spiller B2'], display: 'Spiller B / Spiller B2', teamName: '' }
  }
};

export const namesState = cloneNames(DEFAULT_NAMES.single);

let saveTimer = 0;

export function defaultPlayerName(side, index){
  if(index === 0) return side === 'A' ? 'Spiller A' : 'Spiller B';
  return side === 'A' ? 'Spiller A2' : 'Spiller B2';
}

export function normalizeNameEntry(value, side, discipline){
  const target = discipline || state.matchDiscipline;
  let players = [];

  if(value){
    if(typeof value === 'string'){
      players = [value];
    }else if(Array.isArray(value)){
      players = value.slice();
    }else if(value.players){
      if(Array.isArray(value.players)){
        players = value.players.slice();
      }else if(typeof value.players === 'object'){
        if(value.players.p1) players.push(value.players.p1);
        if(value.players.p2) players.push(value.players.p2);
      }
    }
  }

  players = players.map(function(p){ return (p || '').toString().trim(); }).filter(Boolean);

  if(target === 'double'){
    if(players.length === 0) players.push(defaultPlayerName(side, 0));
    if(players.length === 1) players.push(defaultPlayerName(side, 1));
    players = players.slice(0, 2);
  }else{
    if(players.length === 0) players.push(defaultPlayerName(side, 0));
    players = players.slice(0, 1);
  }

  const teamName = (value && typeof value.teamName === 'string' && value.teamName.trim())
    ? value.teamName.trim()
    : '';

  const display = teamName ? teamName : (value && typeof value.display === 'string' && value.display.trim())
    ? value.display.trim()
    : players.join(' / ');

  return { players, display, teamName };
}

export function alignNamesState(discipline){
  const target = discipline || state.matchDiscipline;
  namesState.A = normalizeNameEntry(namesState.A, 'A', target);
  namesState.B = normalizeNameEntry(namesState.B, 'B', target);
}

export function cloneNames(source){
  return {
    A: { players: source.A.players.slice(), display: source.A.display, teamName: source.A.teamName || '' },
    B: { players: source.B.players.slice(), display: source.B.display, teamName: source.B.teamName || '' }
  };
}

export function getDisplayName(entry, side, discipline){
  return normalizeNameEntry(entry, side, discipline).display;
}

export function serializeNameForSync(entry, side, discipline){
  const normalized = normalizeNameEntry(entry, side, discipline);
  const payload = {
    display: normalized.display,
    players: { p1: normalized.players[0] || defaultPlayerName(side, 0) }
  };
  if(normalized.players[1]) payload.players.p2 = normalized.players[1];
  if(normalized.teamName) payload.teamName = normalized.teamName;
  return payload;
}

export function serializeNames(entries, discipline){
  const disc = discipline || state.matchDiscipline;
  return {
    A: serializeNameForSync(entries.A, 'A', disc),
    B: serializeNameForSync(entries.B, 'B', disc)
  };
}

export function setMatchDiscipline(value){
  if(!value || value === state.matchDiscipline) return;
  state.matchDiscipline = value;
  alignNamesState(value);
}

export function setPlayMode(value){
  if(!value || value === state.playMode) return;
  state.playMode = value;
}

export function resetNamesForDiscipline(discipline){
  const defaults = cloneNames(DEFAULT_NAMES[discipline] || DEFAULT_NAMES.single);
  namesState.A = defaults.A;
  namesState.B = defaults.B;
}

export function saveLiveState(){
  clearTimeout(saveTimer);
  saveTimer = setTimeout(function(){
    try{
      alignNamesState();
      const snapshot = serializeNames(namesState, state.matchDiscipline);
      const data = {
        scoreA: state.scoreA,
        scoreB: state.scoreB,
        setsA: state.setsA,
        setsB: state.setsB,
        currentSet: state.currentSet,
        swappedAt11: state.swappedAt11,
        locked: state.locked,
        setHistory: state.setHistory,
        names: snapshot,
        format: { discipline: state.matchDiscipline, playMode: state.playMode },
        isALeft: document.querySelector('.side.left')?.id === 'sideA',
        summaryVisible: document.getElementById('summaryMask')?.style.display === 'flex',
        allowScoring: state.allowScoring,
        nameEditMode: state.nameEditMode,
        betweenSets: state.betweenSets,
        tournamentData: state.playMode === 'tournament' ? state.tournamentData : null
      };
      localStorage.setItem(LS.LIVE, JSON.stringify(data));
    }catch(_){ }
  }, 80);
}

export function restoreLiveState(options){
  const {
    writeModalInputsFromNames,
    updateNameChips,
    setSidesDomTo,
    syncSplashButtons
  } = options || {};

  try{
    const raw = localStorage.getItem(LS.LIVE);
    if(!raw) return false;
    const d = JSON.parse(raw);

    state.scoreA = d.scoreA || 0;
    state.scoreB = d.scoreB || 0;
    state.setsA = d.setsA || 0;
    state.setsB = d.setsB || 0;
    state.currentSet = d.currentSet || 1;
    state.swappedAt11 = !!d.swappedAt11;
    state.locked = !!d.locked;
    state.setHistory = Array.isArray(d.setHistory) ? d.setHistory : [];
    state.allowScoring = !!d.allowScoring;
    state.nameEditMode = !!d.nameEditMode;
    state.betweenSets = !!d.betweenSets;
    state.matchDiscipline = d.matchDiscipline || d.format?.discipline || 'single';
    state.playMode = d.playMode || d.format?.playMode || 'singleMatch';
    // Only restore tournament data if in tournament mode
    if(state.playMode === 'tournament'){
      state.tournamentData = d.tournamentData || null;
    } else {
      state.tournamentData = null;
    }

    const storedNames = d.names;
    if(storedNames && storedNames.A && storedNames.B){
      namesState.A = normalizeNameEntry(storedNames.A, 'A', state.matchDiscipline);
      namesState.B = normalizeNameEntry(storedNames.B, 'B', state.matchDiscipline);
    }else if(Array.isArray(storedNames)){
      namesState.A = normalizeNameEntry(storedNames[0], 'A', state.matchDiscipline);
      namesState.B = normalizeNameEntry(storedNames[1], 'B', state.matchDiscipline);
    }else{
      namesState.A = normalizeNameEntry(storedNames?.A || 'Spiller A', 'A', state.matchDiscipline);
      namesState.B = normalizeNameEntry(storedNames?.B || 'Spiller B', 'B', state.matchDiscipline);
    }
    
    // Migrate old string format to new object format if needed
    if(typeof namesState.A === 'string'){
      namesState.A = normalizeNameEntry(namesState.A, 'A', state.matchDiscipline);
    }
    if(typeof namesState.B === 'string'){
      namesState.B = normalizeNameEntry(namesState.B, 'B', state.matchDiscipline);
    }

    alignNamesState();

    if(writeModalInputsFromNames){
      writeModalInputsFromNames(namesState);
    }
    if(updateNameChips) updateNameChips();
    if(setSidesDomTo) setSidesDomTo(!(d.isALeft === false));


    const summaryMask = document.getElementById('summaryMask');
    if(summaryMask) summaryMask.style.display = d.summaryVisible ? 'flex' : 'none';

    const nextSetBtn = document.getElementById('nextSetBtn');
    if(nextSetBtn) nextSetBtn.style.display = (!state.IS_SPECTATOR && state.betweenSets) ? 'block' : 'none';

    if(syncSplashButtons) syncSplashButtons();
    return true;
  }catch(_){
    return false;
  }
}

export function clearLiveState(force = false){
  try{
    localStorage.removeItem(LS.LIVE);
    // Only clear tournament data if not in tournament mode, unless forced
    if(force || state.playMode !== 'tournament'){
      state.tournamentData = null;
    }
  }catch(_){ }
}


--------------------------------------------------
File End
--------------------------------------------------


js\ui\autocomplete.js
File type: .js
// Felles autocomplete-helper
import { getPrevNames, pushPrev } from '../services/storage.js';

export function defaultFilter(val){
  const v = (val || '').toLowerCase();
  return function(name){
    return !name.includes(' / ') && name.toLowerCase().includes(v);
  };
}

export function attachAutocomplete(input, { listEl, getCandidates = () => getPrevNames(), onSelect }){
  let current = -1;
  function close(){ if(listEl) listEl.style.display = 'none'; current = -1; }
  function open(){ if(listEl) listEl.style.display = 'block'; }

  input.addEventListener('input', () => {
    if(!listEl) return;
    const val = input.value;
    const src = getCandidates().filter(defaultFilter(val));
    listEl.innerHTML = '';
    if(!val || !src.length){ close(); return; }
    open();
    src.forEach(name => {
      const div = document.createElement('div');
      const strong = document.createElement('strong');
      strong.textContent = name.substr(0, val.length);
      div.appendChild(strong);
      div.appendChild(document.createTextNode(name.substr(val.length)));
      const hidden = document.createElement('input');
      hidden.type = 'hidden'; hidden.value = name;
      div.appendChild(hidden);
      div.addEventListener('click', () => {
        const chosen = hidden.value;
        input.value = chosen;
        pushPrev(chosen);
        close();
        onSelect && onSelect(chosen);
      });
      listEl.appendChild(div);
    });
  });

  input.addEventListener('keydown', (e) => {
    if(!listEl || listEl.style.display !== 'block') return;
    const items = Array.from(listEl.children);
    if(!items.length) return;
    if(e.key === 'ArrowDown'){ e.preventDefault(); current = (current+1) % items.length; setActive(items); }
    else if(e.key === 'ArrowUp'){ e.preventDefault(); current = (current-1+items.length) % items.length; setActive(items); }
    else if(e.key === 'Enter'){ e.preventDefault(); if(current>-1) items[current].click(); }
    else if(e.key === 'Escape'){ close(); }
  });

  document.addEventListener('click', (e) => {
    // Ikke lukk hvis klikket er på dropdown-knappen eller inne i samme wrapper
    const isOnDropdownBtn = !!e.target.closest('.dropdown-btn');
    const wrapper = input.closest('.autocomplete') || input.parentElement;
    const isInsideWrapper = wrapper ? wrapper.contains(e.target) : false;
    if (e.target !== input && !listEl.contains(e.target) && !isOnDropdownBtn && !isInsideWrapper) {
      close();
    }
  });

  function setActive(items){
    items.forEach(x => x.classList.remove('autocomplete-active'));
    if(current>-1 && items[current]) items[current].classList.add('autocomplete-active');
  }
}

export function toggleDropdownFor(input, listEl, getRecent = () => getPrevNames()){
  const recent = getRecent().filter(n => !n.includes(' / ')).slice(0,8);
  listEl.innerHTML = '';
  if(!recent.length){ listEl.style.display = 'none'; return; }
  listEl.style.display = (listEl.style.display === 'block') ? 'none' : 'block';
  if(listEl.style.display !== 'block') return;
  recent.forEach(name => {
    const div = document.createElement('div');
    div.textContent = name;
    div.addEventListener('click', () => {
      input.value = name;
      pushPrev(name);
      listEl.style.display = 'none';
      input.dispatchEvent(new Event('input')); // oppdater chips mm.
    });
    listEl.appendChild(div);
  });
}

// NY: felles helper for å vise/skjule ▼-knapper basert på tilgjengelige kandidater
export function updateDropdownButtons(root){
  const scope = (typeof root === 'string')
    ? document.querySelector(root)
    : (root && root.querySelectorAll ? root : document);
  if(!scope) return;
  const available = getPrevNames().filter(n => !n.includes(' / '));
  const has = available.length > 0;
  const buttons = scope.querySelectorAll('.dropdown-btn');
  buttons.forEach(btn => {
    const input = btn?.parentElement?.querySelector('input');
    if(!input) return;
    if(has){
      btn.classList.remove('hidden');
      input.classList.remove('no-dropdown');
    }else{
      btn.classList.add('hidden');
      input.classList.add('no-dropdown');
    }
  });
}


--------------------------------------------------
File End
--------------------------------------------------


js\ui\layout.js
File type: .js
import { state, getDisplayName } from '../state/matchState.js';
import { $ } from '../dom.js';

let saveLiveStateBound = function(){};
let pushStateThrottled = function(){};
let pushStateNow = function(){};
let updateNameChips = function(){};

export function setLayoutDependencies(deps){
  saveLiveStateBound = deps.saveLiveState || saveLiveStateBound;
  pushStateThrottled = deps.pushStateThrottled || pushStateThrottled;
  pushStateNow = deps.pushStateNow || pushStateNow;
  updateNameChips = deps.updateNameChips || updateNameChips;
}

export function isALeft(){
  var left = document.querySelector('.side.left');
  return left && left.id === 'sideA';
}

export function readABFromModalInputs(){
  const discipline = state.matchDiscipline;
  
  if(discipline === 'double'){
    // Read double format
    const left1 = $('#nameA1')?.value || 'Spiller A';
    const left2 = $('#nameA2')?.value || 'Spiller A2';
    const right1 = $('#nameB1')?.value || 'Spiller B';
    const right2 = $('#nameB2')?.value || 'Spiller B2';
    
    // Read team names
    const teamNameA = $('#teamNameA')?.value?.trim() || '';
    const teamNameB = $('#teamNameB')?.value?.trim() || '';
    
    // Use team name if provided, otherwise use player names
    const leftDisplay = teamNameA ? teamNameA : (left1 + ' / ' + left2);
    const rightDisplay = teamNameB ? teamNameB : (right1 + ' / ' + right2);
    
    const leftVal = { players: [left1, left2], display: leftDisplay, teamName: teamNameA };
    const rightVal = { players: [right1, right2], display: rightDisplay, teamName: teamNameB };
    
    return isALeft()
      ? { A: leftVal,  B: rightVal }
      : { A: rightVal, B: leftVal };
  } else {
    // Read single format
    var leftVal = ($('#nameA')?.value || 'Spiller A');
    var rightVal = ($('#nameB')?.value || 'Spiller B');
    return isALeft()
      ? { A: leftVal,  B: rightVal }
      : { A: rightVal, B: leftVal };
  }
}

export function writeModalInputsFromAB(Aname, Bname){
  const discipline = state.matchDiscipline;
  
  if(discipline === 'double'){
    // Handle double format
    const aPlayers = Array.isArray(Aname?.players) ? Aname.players : [Aname || 'Spiller A', 'Spiller A2'];
    const bPlayers = Array.isArray(Bname?.players) ? Bname.players : [Bname || 'Spiller B', 'Spiller B2'];
    
    // Handle team names
    const aTeamName = Aname?.teamName || '';
    const bTeamName = Bname?.teamName || '';
    
    if(isALeft()){
      $('#nameA1').value = aPlayers[0] || 'Spiller A';
      $('#nameA2').value = aPlayers[1] || 'Spiller A2';
      $('#nameB1').value = bPlayers[0] || 'Spiller B';
      $('#nameB2').value = bPlayers[1] || 'Spiller B2';
      $('#teamNameA').value = aTeamName;
      $('#teamNameB').value = bTeamName;
    }else{
      $('#nameA1').value = bPlayers[0] || 'Spiller B';
      $('#nameA2').value = bPlayers[1] || 'Spiller B2';
      $('#nameB1').value = aPlayers[0] || 'Spiller A';
      $('#nameB2').value = aPlayers[1] || 'Spiller A2';
      $('#teamNameA').value = bTeamName;
      $('#teamNameB').value = aTeamName;
    }
  } else {
    // Handle single format
    const aStr = typeof Aname === 'string' ? Aname : (Aname?.display || Aname?.players?.[0] || 'Spiller A');
    const bStr = typeof Bname === 'string' ? Bname : (Bname?.display || Bname?.players?.[0] || 'Spiller B');
    
    if(isALeft()){
      $('#nameA').value = aStr;
      $('#nameB').value = bStr;
    }else{
      $('#nameA').value = bStr;
      $('#nameB').value = aStr;
    }
  }
}

export function updateNameChipsFromModal(){
  var names = readABFromModalInputs();
  var ca = $('#nameA_chip');
  var cb = $('#nameB_chip');
  
  // Handle both string and object formats
  const aDisplay = getDisplayName(names.A, 'A');
  const bDisplay = getDisplayName(names.B, 'B');
  
  if(ca) ca.textContent = aDisplay;
  if(cb) cb.textContent = bDisplay;
}

export function setSidesDomTo(isALeftTarget){
  var wrap = $('#wrap');
  var A = $('#sideA');
  var B = $('#sideB');
  var divider = document.querySelector('.divider');
  if(!(wrap && A && B && divider)) return;

  var namesBefore = readABFromModalInputs();

  var aIsLeft = A.classList.contains('left');
  if(aIsLeft === isALeftTarget) return;

  wrap.classList.add('no-trans');
  try{
    if(isALeftTarget){
      A.classList.add('left');
      A.classList.remove('right');
      B.classList.add('right');
      B.classList.remove('left');
      wrap.insertBefore(A, wrap.firstElementChild);
      wrap.insertBefore(divider, B);
    }else{
      B.classList.add('left');
      B.classList.remove('right');
      A.classList.add('right');
      A.classList.remove('left');
      wrap.insertBefore(B, wrap.firstElementChild);
      wrap.insertBefore(divider, A);
    }
  }catch(_){ }
  wrap.classList.remove('no-trans');

  if(!state.IS_SPECTATOR){
    writeModalInputsFromAB(namesBefore.A, namesBefore.B);
    updateNameChips();
  }
}

export function startVisualSwap(done){
  if(state.swapping) return;
  state.swapping = true;

  var namesBefore = readABFromModalInputs();
  var wrap = $('#wrap');
  var left = document.querySelector('.side.left');
  var right = document.querySelector('.side.right');
  var divider = document.querySelector('.divider');
  if(!(wrap && left && right && divider)){
    state.swapping = false;
    return;
  }

  wrap.classList.add('swap-go');
  var finished = false;

  function complete(){
    if(finished) return;
    finished = true;
    left.removeEventListener('transitionend', onEnd);
    right.removeEventListener('transitionend', onEnd);

    try{
      wrap.classList.add('no-trans');
      wrap.insertBefore(right, left);
      if(divider.parentNode !== wrap) wrap.appendChild(divider);
      wrap.insertBefore(divider, left);
      left.classList.remove('left');
      left.classList.add('right');
      right.classList.remove('right');
      right.classList.add('left');
    }catch(_){ }

    wrap.classList.remove('swap-go');
    void wrap.offsetWidth;
    wrap.classList.remove('no-trans');

    if(!state.IS_SPECTATOR){
      writeModalInputsFromAB(namesBefore.A, namesBefore.B);
      updateNameChips();
    }

    fitScores();
    state.swapping = false;
    saveLiveStateBound();
    if(typeof pushStateNow === 'function') pushStateNow();

    if(typeof done === 'function'){
      try{ done(); }catch(_){ }
    }
  }

  function onEnd(e){
    if(e.target !== left && e.target !== right) return;
    complete();
  }

  left.addEventListener('transitionend', onEnd);
  right.addEventListener('transitionend', onEnd);
  setTimeout(complete, 1200);
}

export function swapSides(){
  startVisualSwap();
}

export function setDigits(score, prefix){
  var tens = Math.floor(score / 10);
  var ones = score % 10;
  var tensEl = document.getElementById(prefix + '_tens');
  var onesEl = document.getElementById(prefix + '_ones');
  if(score < 10){
    if(tensEl){
      tensEl.textContent = '0';
      tensEl.classList.add('ghost');
    }
  }else{
    if(tensEl){
      tensEl.textContent = String(tens);
      tensEl.classList.remove('ghost');
    }
  }
  if(onesEl) onesEl.textContent = String(ones);
}

export function fitScores(){
  // Skip fitScores during bump animations to prevent visual interference
  if(_bumpInProgress) return;

  document.body.classList.add('measuring');
  var base = 100;
  var scoreAEl = $('#scoreA');
  var scoreBEl = $('#scoreB');
  if(!(scoreAEl && scoreBEl)){
    document.body.classList.remove('measuring');
    return;
  }

  scoreAEl.style.fontSize = base + 'px';
  scoreBEl.style.fontSize = base + 'px';

  var nameAH = ($('#sideA .name')||{}).offsetHeight || 0;
  var nameBH = ($('#sideB .name')||{}).offsetHeight || 0;

  function padY(el){
    var cs = getComputedStyle(el);
    return (parseFloat(cs.paddingTop)||0) + (parseFloat(cs.paddingBottom)||0);
  }

  function padX(el){
    var cs = getComputedStyle(el);
    return (parseFloat(cs.paddingLeft)||0) + (parseFloat(cs.paddingRight)||0);
  }

  var availHA = Math.max(40, ($('#sideA')?.clientHeight || 0) - nameAH - padY($('#sideA')));
  var availHB = Math.max(40, ($('#sideB')?.clientHeight || 0) - nameBH - padY($('#sideB')));
  var availWA = Math.max(40, ($('#sideA .scoreBox')?.clientWidth || 0) - padX(scoreAEl));
  var availWB = Math.max(40, ($('#sideB .scoreBox')?.clientWidth || 0) - padX(scoreBEl));

  var aRect = $('#A_digits').getBoundingClientRect();
  var bRect = $('#B_digits').getBoundingClientRect();

  var scaleA = Math.min(availWA/Math.max(1,aRect.width), availHA/Math.max(1,aRect.height));
  var scaleB = Math.min(availWB/Math.max(1,bRect.width), availHB/Math.max(1,bRect.height));
  var font = Math.floor(base * Math.max(0.01, Math.min(scaleA, scaleB)));

  scoreAEl.style.fontSize = font + 'px';
  scoreBEl.style.fontSize = font + 'px';
  document.body.classList.remove('measuring');
  saveLiveStateBound();
}

export const queueFit = (function(){
  var raf = 0;
  var timeout = 0;
  return function(){
    cancelAnimationFrame(raf);
    clearTimeout(timeout);
    raf = requestAnimationFrame(function(){
      fitScores();
      timeout = setTimeout(fitScores, 60);
    });
  };
})();

// Global flag to prevent fitScores during bump animations
let _bumpInProgress = false;

export function bumpPlus(el){
  if(!el) return;
  _bumpInProgress = true;
  el.classList.remove('pop');
  void el.offsetWidth;
  el.classList.add('pop');
  setTimeout(function(){ 
    el.classList.remove('pop');
    _bumpInProgress = false;
  }, 550);
}

export function bumpMinus(el){
  if(!el) return;
  _bumpInProgress = true;
  el.classList.remove('popMinus');
  void el.offsetWidth;
  el.classList.add('popMinus');
  setTimeout(function(){ 
    el.classList.remove('popMinus');
    _bumpInProgress = false;
  }, 550);
}

export function handleScoreBump(prevScore, newScore, element){
  if(prevScore !== null && newScore !== prevScore) {
    ((newScore > prevScore) ? bumpPlus : bumpMinus)(element);
  }
}

export function clearWinner(){
  ['#scoreA','#scoreB'].forEach(function(sel){
    var el = $(sel);
    if(el) el.classList.remove('winner');
  });
  ['#nameA_chip','#nameB_chip'].forEach(function(sel){
    var el = $(sel);
    if(el) el.classList.remove('winnerName');
  });
}


--------------------------------------------------
File End
--------------------------------------------------


js\ui\matchView.js
File type: .js
import { state, saveLiveState, restoreLiveState, clearLiveState, namesState, normalizeNameEntry, alignNamesState, getDisplayName } from '../state/matchState.js';
import { setDigits, fitScores, queueFit, handleScoreBump, swapSides, setLayoutDependencies, readABFromModalInputs, writeModalInputsFromAB, clearWinner, isALeft, startVisualSwap, setSidesDomTo } from './layout.js';
import { showNameModal, hideNameModal, updateEditableState, updateNameChips, autocomplete, onSaveNames } from './namesModal.js';
import { loadMatches, saveMatches, saveLastNames, loadLastNames } from '../services/storage.js';
import { initShare, openShare, closeShare } from './share.js';
import { renderStats, showMatch } from './statsView.js';
import { setupMenu, renderMenu } from './menu.js';
import { hasActiveMatchState, getContinueLabel, isAtStart } from './session.js';
import { setupSplash, showSplash, hideSplash, syncSplashButtons, setSplashContinueState } from './splash.js';
import { setupTournamentSetup, showTournamentSetup } from './tournamentSetup.js';
import { getGameRef, ensureGameId, generateNewGameId } from '../services/firebase.js';
import { bindFirebaseSync, unbindFirebaseSync, setFirebaseSyncDependencies } from '../services/firebaseSync.js';
import { initWriteAccess, hasWriteAccess, claimWriteAccess, releaseWriteAccess, setWriteAccessDependencies, getWriteAccessStatus } from '../services/writeAccess.js';
import { setupTournamentOverview, hideTournamentOverview, renderTournamentOverview } from './tournamentOverview.js';
import { setupFirebase, pushStateThrottled, pushStateNow, spectatorShareUrl } from '../services/firebase.js';
import { toast, setBodyScroll, $ } from '../dom.js';
import { openModal, closeModal } from './modal.js';
import { qs, on, toggle } from '../util/domUtils.js';
import { LONGPRESS_MS, MOVE_THRESH } from '../constants.js';
import { bindNameInput } from '../services/namesStore.js';

/**
 * Match View Event Binding Contract:
 * 
 * enterMatch() - Binds all necessary event listeners for match interaction
 * exitMatch() - Removes all bound event listeners to prevent double-binding
 * 
 * This prevents duplicate event handlers when navigating in/out of match view
 */


function openFinishDialog(){
  const settled = (state.setsA >= 2 || state.setsB >= 2);
  showFinishDialog(!settled);
}

// Lokal helper: hent visningsnavn for A/B konsistent
function getCurrentDisplayNames(){
  const names = readABFromModalInputs();
  return {
    aDisplay: getDisplayName(names.A, 'A'),
    bDisplay: getDisplayName(names.B, 'B')
  };
}

const saveState = () => saveLiveState(readABFromModalInputs);

// Event binding state
let isMatchBound = false;
let boundHandlers = {
  scoreA: null,
  scoreB: null,
  leftArea: null,
  rightArea: null,
  keydown: null
};

// Teller read state
let _unsubCounter = null;

// Cache DOM elements for performance (used by counterRead.js)
const elA = document.getElementById('A_digits');
const elB = document.getElementById('B_digits');


// Lokalt suppress-vindu for å ignorere umiddelbar echo fra RTDB (ms tidsstempel per side)
let _localBumpSuppress = { A: 0, B: 0 };

setLayoutDependencies({
  saveLiveState: saveState,
  pushStateThrottled: () => pushStateThrottled(),
  pushStateNow: () => pushStateNow(),
  updateNameChips
});

// Gi teller-leseren tilgang til våre UI-oppdaterere (unngår window.*)
setFirebaseSyncDependencies({
  updateScores,
  fitScores,
  handleScoreBump,
  clearWinner,
  getSuppressUntil: (side) => _localBumpSuppress[side] || 0,
  startVisualSwap,
  setSidesDomTo
});

// Set up write access system
setWriteAccessDependencies({
  onWriteAccessChange: function(status) {
    console.log('[WRITE ACCESS] Access changed:', status);
    // Rebind Firebase with new write access status
    if (state.IS_COUNTER) {
      rebindFirebaseWithWriteAccess();
    }
  },
  pushStateNow: () => pushStateNow(),
  getGameRef: () => getGameRef()
});

let menuHandlers;
let shareInitialized = false;

// Helper function to rebind Firebase with current write access
function rebindFirebaseWithWriteAccess(){
  if (!state.IS_COUNTER) return;
  
  unbindFirebaseSync();
  
  var gid = ensureGameId();
  var ref = getGameRef(gid);
  if(ref){
    var role = state.IS_COCOUNTER ? 'cocounter' : 'counter';
    var canWrite = hasWriteAccess();
    console.log('[WRITE ACCESS] Rebinding Firebase - role:', role, 'canWrite:', canWrite);
    _unsubCounter = bindFirebaseSync({ role, ref, canWrite });
  }
}

export function mount(){
  setupMenu({ isSpectator: state.IS_SPECTATOR });
  menuHandlers = buildMenuHandlers();
  renderMenu(state.VIEW_MODE, menuHandlers);

  if(!shareInitialized){
    initShare({ getShareUrl: spectatorShareUrl });
    shareInitialized = true;
  }

  bindModalEvents();
  bindSummaryEvents();

  addEventListener('resize', queueFit);
  if(window.visualViewport) window.visualViewport.addEventListener('resize', queueFit);
  addEventListener('orientationchange', function(){ setTimeout(queueFit, 60); });

  setupSplash({ onStart: startMatchFlow, saveState: saveState });
  setupTournamentSetup();
  setupTournamentOverview();

  // Only setup Firebase if we're not just showing splash
  // Check if we have URL parameters that indicate we need Firebase
  const urlParams = new URLSearchParams(window.location.search);
  const hasGameParam = urlParams.has('game');
  const hasMode = urlParams.has('mode');
  
  if (hasGameParam || hasMode || state.IS_SPECTATOR || !document.body.classList.contains('splash-open')) {
    setupFirebase({ updateScores });
  }

  if(state.IS_SPECTATOR){
    document.body.classList.remove('areas-active');
    const menu = qs('#menuPanel');
    if(menu) menu.style.display = 'none';
  }else{
    maybeShowKebabHint();
  }

  updateScores();
  fitScores();
}

export function startMatchFlow(opts){
  opts = opts || {};
  const restored = !!opts.restored;
  const skipSplash = !!opts.skipSplash;
  const continueMatch = !!opts.continueMatch;
  const directJoin = !!opts.directJoin; // Joining via shared URL
  const fromSplash = !!opts.fromSplash; // Started from splash screen
  let handledStart = false;
  
  // Setup Firebase when starting from splash (if not already done)
  if (fromSplash && !window.firebase) {
    console.log('[MATCH FLOW] Setting up Firebase from splash');
    setupFirebase({ updateScores });
  } else if (fromSplash && window.firebase) {
    console.log('[MATCH FLOW] Firebase already initialized, skipping setup');
  }

  if(!state.IS_SPECTATOR){
    if(continueMatch){
      // Check if we should go to tournament overview instead of auto-resuming match
      if(state.playMode === 'tournament' && state.ui && state.ui.nextNavHint === 'continueTournament'){
        // Navigate to tournament overview instead of auto-resuming
        import('./tournamentOverview.js').then(function(module){
          module.showTournamentOverview();
        });
        // Clear the navigation hint after use
        if(state.ui) state.ui.nextNavHint = null;
        return;
      }
      
      // Navigate to match URL for refresh support when continuing match
      try {
        import('../services/firebase.js').then(function(firebaseModule) {
          const gameId = firebaseModule.ensureGameId();
          const mode = state.IS_COCOUNTER ? 'cocounter' : 'counter';
          const matchUrl = firebaseModule.generateShareUrl(mode, gameId);
          window.history.replaceState({}, '', matchUrl);
          console.log('[CONTINUE MATCH] Navigated to match URL:', matchUrl);
        });
      } catch (e) {
        console.warn('[CONTINUE MATCH] Failed to navigate to match URL:', e);
      }
      
      handledStart = true;
    }

    if(!restored && !skipSplash && !continueMatch){
      if(state.playMode === 'tournament'){
        showTournamentSetup();
      }else{
        // Viktig: full reset før navn-modal for å unngå "låst" skjerm
        // Bruk samme løype som "Ny kamp"
        // Hopper over splash og åpner navn-modal via startNewMatch
        startNewMatch({ skipSplash: true });
      }
      handledStart = true;
    }

    // Handle direct join via shared URL - enable scoring immediately
    if(directJoin && !state.IS_SPECTATOR){
      state.allowScoring = true;
      handledStart = true;
    }
    
    if(!handledStart && !state.allowScoring){
      showNameModal(true);
    }
    updateNameChips();
  }

  updateEditableState();
  saveState();
  
  // Enter match view - bind event listeners
  enterMatch();
}

function bindCoreEvents(){
  if(!state.IS_SPECTATOR){
    // Store handlers for cleanup
    boundHandlers.scoreA = () => addPoint('A');
    boundHandlers.scoreB = () => addPoint('B');
    boundHandlers.leftArea = () => addPointByPosition('left');
    boundHandlers.rightArea = () => addPointByPosition('right');
    
    bindLongPressOne($('#scoreA'), () => removePoint('A'));
    bindLongPressOne($('#scoreB'), () => removePoint('B'));
    bindTap($('#scoreA'), boundHandlers.scoreA);
    bindTap($('#scoreB'), boundHandlers.scoreB);
    bindLongPressOne($('#leftArea'), () => removePointByPosition('left'));
    bindLongPressOne($('#rightArea'), () => removePointByPosition('right'));
    bindTap($('#leftArea'), boundHandlers.leftArea);
    bindTap($('#rightArea'), boundHandlers.rightArea);
  }

  const nameAInput = qs('#nameA');
  const nameBInput = qs('#nameB');
  const nameA1Input = qs('#nameA1');
  const nameA2Input = qs('#nameA2');
  const nameB1Input = qs('#nameB1');
  const nameB2Input = qs('#nameB2');
  const teamNameAInput = qs('#teamNameA');
  const teamNameBInput = qs('#teamNameB');
  
  if(nameAInput) {
    autocomplete(nameAInput, 'nameA-list');
    bindNameInput(nameAInput);
  }
  if(nameBInput) {
    autocomplete(nameBInput, 'nameB-list');
    bindNameInput(nameBInput);
  }
  if(nameA1Input) {
    autocomplete(nameA1Input, 'nameA1-list');
    bindNameInput(nameA1Input);
  }
  if(nameA2Input) {
    autocomplete(nameA2Input, 'nameA2-list');
    bindNameInput(nameA2Input);
  }
  if(nameB1Input) {
    autocomplete(nameB1Input, 'nameB1-list');
    bindNameInput(nameB1Input);
  }
  if(nameB2Input) {
    autocomplete(nameB2Input, 'nameB2-list');
    bindNameInput(nameB2Input);
  }
  
  // Add event listeners for team name inputs to update chips
  if(teamNameAInput) {
    on(teamNameAInput, 'input', updateNameChips);
    on(teamNameAInput, 'blur', updateNameChips);
  }
  if(teamNameBInput) {
    on(teamNameBInput, 'input', updateNameChips);
    on(teamNameBInput, 'blur', updateNameChips);
  }
}

function bindModalEvents(){
  const cancel = $('#btnCancelNames');
  if(cancel) on(cancel, 'click', hideNameModal);

  const saveBtn = $('#btnSaveNames');
  if(saveBtn) on(saveBtn, 'click', function(){
    onSaveNames(saveState, () => pushStateThrottled());
  });

  const startBtn = $('#btnStart');
  if(startBtn) startBtn.addEventListener('click', function(){
    onSaveNames(saveState, () => pushStateThrottled());
    state.allowScoring = true;
    state.nameEditMode = false;
    saveState();
  });
}

function bindSummaryEvents(){
  const closeBtn = document.getElementById('summaryClose');
  const closeSummaryBtn = document.getElementById('btnCloseSummary');
  const newMatchBtn = document.getElementById('btnNewMatch');
  const quickStartBtn = document.getElementById('btnQuickStart');
  const finishMatchBtn = document.getElementById('btnFinishMatch');
  const showSummaryBtn = document.getElementById('showSummaryBtn');
  const mask = document.getElementById('summaryMask');
  const nextSetBtn = document.getElementById('nextSetBtn');

  // Handle tournament mode button click
  if(finishMatchBtn) {
    finishMatchBtn.addEventListener('click', function(){
      if(state.playMode !== 'tournament') return;
      openFinishDialog();
    });
  }
  
  if(newMatchBtn) {
    newMatchBtn.style.display = state.playMode === 'tournament' ? 'none' : 'inline-block';
  }
  
  if(quickStartBtn) {
    quickStartBtn.style.display = state.playMode === 'tournament' ? 'none' : 'inline-block';
  }

  if(closeBtn) closeBtn.addEventListener('click', closeSummaryModal);
  if(closeSummaryBtn) closeSummaryBtn.addEventListener('click', closeSummaryModal);
  if(newMatchBtn) newMatchBtn.addEventListener('click', function(){ closeSummaryModal(); startNewMatch(); });
  if(quickStartBtn) quickStartBtn.addEventListener('click', function(){ 
    closeSummaryModal(); 
    if(state.playMode === 'tournament'){
      // In tournament mode, keep same format but reset scores
      startNewMatch({ skipSplash: true });
    } else {
      // In single match mode, use quick start
      startNewMatch({ skipSplash: true });
    }
  });
  if(showSummaryBtn) showSummaryBtn.addEventListener('click', function(){
    const names = readABFromModalInputs();
    const aDisplay = getDisplayName(names.A, 'A');
    const bDisplay = getDisplayName(names.B, 'B');
    const winnerName = (state.setsA === 2) ? aDisplay : bDisplay;
    renderSummary(winnerName);
  });
  if(mask) mask.addEventListener('click', function(e){ if(e.target === mask) closeSummaryModal(); });
  if(nextSetBtn) nextSetBtn.addEventListener('click', function(){ if(!state.IS_SPECTATOR) advanceToNextSet(); });

  // Store keydown handler for cleanup
  boundHandlers.keydown = function(e){
    if(state.IS_SPECTATOR) return;
    if(state.betweenSets && (e.key === 'Enter' || e.key === ' ' || e.key.toLowerCase() === 'n')){
      e.preventDefault();
      advanceToNextSet();
    }
  };
  document.addEventListener('keydown', boundHandlers.keydown);
}

/**
 * Enter match view - bind all necessary event listeners
 */
export function enterMatch(){
  if(isMatchBound) return; // Prevent double-binding
  
  bindCoreEvents();
  
  // Initialize write access system
  if(state.IS_COUNTER) {
    initWriteAccess();
  }
  
  // Bind teller read handlers for live updates
  if(state.IS_COUNTER) {
    rebindFirebaseWithWriteAccess();
  }
  
  isMatchBound = true;
}

/**
 * Exit match view - remove all bound event listeners
 */
export function exitMatch(){
  if(!isMatchBound) return;
  
  // Remove event listeners
  if(boundHandlers.scoreA && $('#scoreA')) {
    $('#scoreA').removeEventListener('click', boundHandlers.scoreA);
  }
  if(boundHandlers.scoreB && $('#scoreB')) {
    $('#scoreB').removeEventListener('click', boundHandlers.scoreB);
  }
  if(boundHandlers.leftArea && $('#leftArea')) {
    $('#leftArea').removeEventListener('click', boundHandlers.leftArea);
  }
  if(boundHandlers.rightArea && $('#rightArea')) {
    $('#rightArea').removeEventListener('click', boundHandlers.rightArea);
  }
  if(boundHandlers.keydown) {
    document.removeEventListener('keydown', boundHandlers.keydown);
  }
  
  // Clean up teller read handlers
  try { 
    if (_unsubCounter) _unsubCounter(); 
  } catch(e){}
  try { 
    unbindFirebaseSync(); 
  } catch(e){}
  _unsubCounter = null;
  
  // Reset state
  isMatchBound = false;
  boundHandlers = {
    scoreA: null,
    scoreB: null,
    leftArea: null,
    rightArea: null,
    keydown: null
  };
  
  // Reset suppress window
  _localBumpSuppress.A = _localBumpSuppress.B = 0;
}

function updateTournamentActionButtons(){
  const finishBtn = document.getElementById('btnFinishMatch');
  const isTournament = state.playMode === 'tournament';
  const completedSets = state.setsA >= 2 || state.setsB >= 2;
  if(finishBtn) finishBtn.style.display = isTournament && completedSets ? 'inline-block' : 'none';
}

// Finish dialog event listeners
(function bindFinishDialogEvents(){
  const mask = document.getElementById('finishMatchMask');
  if(!mask) return;

  const btnPlayed = document.getElementById('finishMatchPlayed');
  const btnWalkoverA = document.getElementById('finishMatchWalkoverA');
  const btnWalkoverB = document.getElementById('finishMatchWalkoverB');
  const btnCancel = document.getElementById('finishMatchCancel');

  btnPlayed?.addEventListener('click', function(){
    finalizeTournamentMatch({ type: 'played' });
    hideFinishDialog();
    toast('Kampen er ferdig. Resultatet er lagret.');
  });

  btnWalkoverA?.addEventListener('click', function(){
    finalizeTournamentMatch({ type: 'walkover', winnerSide: 'A' });
    hideFinishDialog();
    toast('Walkover registrert. Lag A får seieren.');
  });

  btnWalkoverB?.addEventListener('click', function(){
    finalizeTournamentMatch({ type: 'walkover', winnerSide: 'B' });
    hideFinishDialog();
    toast('Walkover registrert. Lag B får seieren.');
  });

  btnCancel?.addEventListener('click', hideFinishDialog);
  // Lokal backdrop-lytter ikke nødvendig lenger når modal.js håndterer dette
})();

function showFinishDialog(disablePlayed) {
  const mask = document.getElementById('finishMatchMask');
  if(!mask) return;
  openModal('#finishMatchMask', { closeOnBackdrop: true, closeOnEsc: true });
  
  const playedBtn = document.getElementById('finishMatchPlayed');
  const info = document.getElementById('finishMatchInfo');
  const walkA = document.getElementById('finishMatchWalkoverA');
  const walkB = document.getElementById('finishMatchWalkoverB');
  
  if(!disablePlayed){
    if(playedBtn){
      playedBtn.style.display = 'block';
      playedBtn.disabled = false;
    }
    if(walkA) walkA.style.display = 'none';
    if(walkB) walkB.style.display = 'none';
    if(info) info.style.display = 'none';
  }else{
    if(playedBtn) playedBtn.style.display = 'none';
    if(info){
      info.style.display = 'block';
      info.textContent = 'Fullfør settene (best av tre) før du kan markere kampen som spilt.';
    }
    if(walkA) walkA.style.display = 'block';
    if(walkB) walkB.style.display = 'block';
  }
  
  document.getElementById('finishMatchHint').textContent = disablePlayed
    ? 'Walkover kan registreres selv om kampen ikke er spilt ferdig.'
    : 'Velg hvordan du vil avslutte kampen.';
}

function hideFinishDialog(){
  const mask = document.getElementById('finishMatchMask');
  if(!mask) return;
  closeModal('#finishMatchMask');
  
  const playedBtn = document.getElementById('finishMatchPlayed');
  const info = document.getElementById('finishMatchInfo');
  const walkA = document.getElementById('finishMatchWalkoverA');
  const walkB = document.getElementById('finishMatchWalkoverB');
  if(playedBtn){
    playedBtn.style.display = 'block';
    playedBtn.disabled = false;
  }
  if(walkA) walkA.style.display = 'block';
  if(walkB) walkB.style.display = 'block';
  if(info) info.style.display = 'none';
}

function updateScores(){
  setDigits(state.scoreA, 'A');
  setDigits(state.scoreB, 'B');

  const counterA = document.getElementById('setCounterA');
  const counterB = document.getElementById('setCounterB');
  if(counterA){
    counterA.textContent = String(state.setsA);
    counterA.style.display = state.setsA > 0 ? 'flex' : 'none';
  }
  if(counterB){
    counterB.textContent = String(state.setsB);
    counterB.style.display = state.setsB > 0 ? 'flex' : 'none';
  }

  const setsEl = document.getElementById('sets');
  if(setsEl){
    setsEl.textContent = 'Sett: ' + state.setsA + '-' + state.setsB;
    setsEl.style.display = (state.setsA + state.setsB) > 0 ? 'block' : 'none';
  }

  updateEditableState();
  
  // Update "Neste sett" button visibility
  const nextSetBtn = document.getElementById('nextSetBtn');
  if(nextSetBtn) nextSetBtn.style.display = (!state.IS_SPECTATOR && state.betweenSets) ? 'block' : 'none';
  
  // Save tournament match state
  if(state.playMode === 'tournament' && state.tournamentData?.activeMatchId){
    const id = state.tournamentData.activeMatchId;
    const store = state.tournamentData.matchStates || (state.tournamentData.matchStates = {});
    const entry = store[id] || (store[id] = {
      scoreA: 0, scoreB: 0, setsA: 0, setsB: 0,
      currentSet: 1, setHistory: [], locked: false,
      betweenSets: false, pendingSetWinner: null,
      swappedAt11: false, status: 'pending'
    });
    entry.scoreA = state.scoreA;
    entry.scoreB = state.scoreB;
    entry.setsA = state.setsA;
    entry.setsB = state.setsB;
    entry.currentSet = state.currentSet;
    entry.setHistory = state.setHistory.slice();
    entry.locked = state.locked;
    entry.betweenSets = state.betweenSets;
    entry.pendingSetWinner = state.pendingSetWinner;
    entry.swappedAt11 = state.swappedAt11;
    if(entry.status === 'pending' && (state.scoreA > 0 || state.scoreB > 0 || state.setHistory.length)){
      entry.status = 'in-progress';
    }
  }
  
  // Update tournament overview if visible
  renderTournamentOverview();
  
  // Update tournament action buttons
  updateTournamentActionButtons();
  
  // Bump effects handled by counterRead.js for live updates
  // Local bump logic removed to prevent double bump
  
  saveState();
}


function addPoint(side){
  // Workflow checks: Is match ready for scoring?
  if(!state.allowScoring || state.locked || state.swapping) return;
  
  // Security check: Does user have write access? (handles spectator + counter/cocounter)
  if(!hasWriteAccess()) {
    if(state.IS_SPECTATOR) {
      // Spectators shouldn't even see score buttons, but just in case
      return;
    } else {
      toast('Du har ikke skrivetilgang. Klikk "Ta kontroll" for å telle poeng.');
      return;
    }
  }
  
  var oldScore = side === 'A' ? state.scoreA : state.scoreB;
  if(side === 'A') state.scoreA++; else state.scoreB++;
  var newScore = side === 'A' ? state.scoreA : state.scoreB;
  
  // Immediate local bump for responsiveness
  var now = Date.now();
  if (side === 'A' && elA) {
    handleScoreBump(oldScore, newScore, elA);
    _localBumpSuppress.A = now + 250;
  } else if (side === 'B' && elB) {
    handleScoreBump(oldScore, newScore, elB);
    _localBumpSuppress.B = now + 250;
  }
  
  // (ikke nødvendig lenger – navn lagres når de settes i modal/turnering)
  checkSetEnd();
  updateScores();
  
  fitScores();
  pushStateThrottled();
}

function removePoint(side){
  // Workflow checks: Is match ready for scoring?
  if(!state.allowScoring || state.locked || state.swapping) return;
  
  // Security check: Does user have write access? (handles spectator + counter/cocounter)
  if(!hasWriteAccess()) {
    if(state.IS_SPECTATOR) {
      // Spectators shouldn't even see score buttons, but just in case
      return;
    } else {
      toast('Du har ikke skrivetilgang. Klikk "Ta kontroll" for å telle poeng.');
      return;
    }
  }
  
  var oldScore = side === 'A' ? state.scoreA : state.scoreB;
  if(side === 'A' && state.scoreA > 0) state.scoreA--;
  if(side === 'B' && state.scoreB > 0) state.scoreB--;
  var newScore = side === 'A' ? state.scoreA : state.scoreB;
  
  // Immediate local bump for responsiveness
  var now = Date.now();
  if (side === 'A' && elA) {
    handleScoreBump(oldScore, newScore, elA);
    _localBumpSuppress.A = now + 250;
  } else if (side === 'B' && elB) {
    handleScoreBump(oldScore, newScore, elB);
    _localBumpSuppress.B = now + 250;
  }
  
  updateScores();
  
  fitScores();
  pushStateThrottled();
}

function addPointByPosition(pos){
  const aLeft = isALeft();
  addPoint((pos === 'left') ? (aLeft ? 'A' : 'B') : (aLeft ? 'B' : 'A'));
}

function removePointByPosition(pos){
  const aLeft = isALeft();
  removePoint((pos === 'left') ? (aLeft ? 'A' : 'B') : (aLeft ? 'B' : 'A'));
}

function pushSetToHistory(a, b){
  const winner = (a > b) ? 'A' : (b > a ? 'B' : '-');
  state.setHistory.push({ set: state.currentSet, a: a, b: b, winner: winner });
  saveState();
}

function renderSummary(finalWinnerName){
  const names = readABFromModalInputs();
  const sumNameA = document.getElementById('sumNameA');
  const sumNameB = document.getElementById('sumNameB');
  const { aDisplay, bDisplay } = getCurrentDisplayNames();
  
  if(sumNameA) sumNameA.textContent = aDisplay;
  if(sumNameB) sumNameB.textContent = bDisplay;

  // Update player names row for double format
  const playersRow = document.getElementById('summaryPlayersRow');
  const sumPlayersA = document.getElementById('sumPlayersA');
  const sumPlayersB = document.getElementById('sumPlayersB');
  
  if(state.matchDiscipline === 'double' && typeof names.A === 'object' && names.A.players) {
    // Show player names row for double format
    if(playersRow) playersRow.style.display = 'table-row';
    
    // Show individual player names
    const aPlayers = names.A.players.join(' / ');
    const bPlayers = names.B.players.join(' / ');
    
    if(sumPlayersA) sumPlayersA.textContent = aPlayers;
    if(sumPlayersB) sumPlayersB.textContent = bPlayers;
  } else {
    // Hide player names row for single format
    if(playersRow) playersRow.style.display = 'none';
  }

  // Update format indicator
  const formatIndicator = document.getElementById('summaryFormat');
  if(formatIndicator){
    const formatText = state.matchDiscipline === 'double' ? '(Dobbel)' : '(Singel)';
    formatIndicator.textContent = formatText;
  }
  
  // Update quick start button text based on play mode
  const quickStartBtn = document.getElementById('btnQuickStart');
  if(quickStartBtn){
    if(state.playMode === 'tournament'){
      quickStartBtn.textContent = '⚡ Neste kamp';
    } else {
      quickStartBtn.textContent = '⚡ Hurtigstart';
    }
  }

  const body = document.getElementById('summaryBody');
  if(body){
    body.innerHTML = '';
    state.setHistory.forEach(function(set){
      const tr = document.createElement('tr');
      const tdSet = document.createElement('td'); tdSet.textContent = String(set.set); tr.appendChild(tdSet);
      const tdA = document.createElement('td'); tdA.textContent = String(set.a); tr.appendChild(tdA);
      const tdB = document.createElement('td'); tdB.textContent = String(set.b); tr.appendChild(tdB);
      const tdW = document.createElement('td');
      const winnerDisplay = set.winner === 'A' ? aDisplay : (set.winner === 'B' ? bDisplay : '—');
      tdW.textContent = winnerDisplay;
      tr.appendChild(tdW);
      body.appendChild(tr);
    });
  }

  const winnerEl = document.getElementById('summaryWinner');
  if(winnerEl) winnerEl.textContent = finalWinnerName ? ('🎉 ' + finalWinnerName + ' vant kampen! 🎉') : '';

  openModal('#summaryMask');
  saveState();
}


function checkSetEnd(){
  const leadOk = Math.abs(state.scoreA - state.scoreB) >= 2 || state.scoreA === state.cap || state.scoreB === state.cap;
  if((state.scoreA >= state.target || state.scoreB >= state.target) && leadOk){
    const winner = (state.scoreA > state.scoreB) ? 'A' : 'B';
    pushSetToHistory(state.scoreA, state.scoreB);

    const willFinish = (winner === 'A') ? (state.setsA + 1 >= 2) : (state.setsB + 1 >= 2);
    if(willFinish){
      if(winner === 'A') state.setsA++; else state.setsB++;
      state.locked = true;
      state.betweenSets = false;
      state.pendingSetWinner = null;

      const { aDisplay, bDisplay } = getCurrentDisplayNames();
      const winnerName = winner === 'A' ? aDisplay : bDisplay;

      if(winner === 'A'){
        toggle(qs('#scoreA'), 'winner', true);
        toggle(qs('#nameA_chip'), 'winnerName', true);
      }else{
        toggle(qs('#scoreB'), 'winner', true);
        toggle(qs('#nameB_chip'), 'winnerName', true);
      }

      const summaryBtn = document.getElementById('showSummaryBtn');
      if(summaryBtn) summaryBtn.style.display = 'block';

      const matchObj = { ts: Date.now(), names: { A: aDisplay, B: bDisplay }, sets: state.setHistory.slice(), winner: winnerName };
      const arr = loadMatches();
      arr.unshift(matchObj);
      saveMatches(arr);
      saveLastNames(aDisplay, bDisplay);

      updateScores();
      fitScores();
      saveState();
      pushStateThrottled();
      return;
    }

    if(winner === 'A') state.setsA++; else state.setsB++;
    state.pendingSetWinner = winner;
    state.betweenSets = true;
    state.locked = true;

    const nextSetBtn = document.getElementById('nextSetBtn');
    if(nextSetBtn && !state.IS_SPECTATOR) nextSetBtn.style.display = 'block';

    updateScores();
    fitScores();
    saveState();
    pushStateThrottled();
    return;
  }

  const isDecider = (state.setsA === 1 && state.setsB === 1);
  if(state.currentSet === 3 && isDecider && !state.swappedAt11 && (state.scoreA === 11 || state.scoreB === 11)){
    startVisualSwap();
    state.swappedAt11 = true;
  }

  saveState();
}

function advanceToNextSet(){
  if(!state.betweenSets) return;
  state.locked = true;
  const nextSetBtn = document.getElementById('nextSetBtn');
  if(nextSetBtn) nextSetBtn.style.display = 'none';

  state.currentSet++;
  state.swappedAt11 = false;

  startVisualSwap(function(){
    state.scoreA = 0;
    state.scoreB = 0;
    state.betweenSets = false;
    state.pendingSetWinner = null;
    state.locked = false;
    updateScores();
    fitScores();
    saveState();
    setTimeout(function(){ pushStateNow(); }, 1050);
  });
}

function resetSet(){
  state.betweenSets = false;
  state.pendingSetWinner = null;
  state.scoreA = 0;
  state.scoreB = 0;
  state.swappedAt11 = false;
  const nextSetBtn = document.getElementById('nextSetBtn');
  if(nextSetBtn) nextSetBtn.style.display = 'none';
  updateScores();
  fitScores();
  saveState();
  pushStateThrottled();
}

function startNewMatch(opts){
  opts = opts || {};
  const skipSplash = !!opts.skipSplash;
  
  console.log('[STATE RESET] startNewMatch called with opts:', opts);
  console.log('[STATE RESET] Current state before reset:', {
    scoreA: state.scoreA, scoreB: state.scoreB,
    setsA: state.setsA, setsB: state.setsB,
    currentSet: state.currentSet, playMode: state.playMode
  });
  
  // Generate new game ID for new match to avoid permission conflicts
  generateNewGameId();
  
  // Navigate to match URL for refresh support
  try {
    import('../services/firebase.js').then(function(firebaseModule) {
      const matchUrl = firebaseModule.generateShareUrl('counter', firebaseModule.ensureGameId());
      window.history.replaceState({}, '', matchUrl);
      console.log('[NEW MATCH] Navigated to match URL:', matchUrl);
    });
  } catch (e) {
    console.warn('[NEW MATCH] Failed to navigate to match URL:', e);
  }
  
  // Firebase should already be initialized from startMatchFlow
  // No need to set it up again here
  console.log('[NEW MATCH] Firebase status:', !!window.firebase);
  
  // ELEGANT: When starting new match from splash, ensure user becomes counter (not cocounter)
  if (!skipSplash && window.location.search.includes('mode=cocounter')) {
    console.log('[STATE RESET] Removing cocounter mode from URL for new match');
    // Use router function instead of direct reload
    import('../main.js').then(function(module) {
      module.navigateToCounterMode();
    });
    return;
  }
  
  // Tøm lagret live-state for å unngå at locked/betweenSets lekker inn i ny kamp
  // (clearLiveState lar turneringsdata stå, hvis playMode === 'tournament')
  clearLiveState();
  
  state.betweenSets = false;
  state.pendingSetWinner = null;
  state.scoreA = 0;
  state.scoreB = 0;
  state.setsA = 0;
  state.setsB = 0;
  state.currentSet = 1;
  state.swappedAt11 = false;
  state.locked = false;
  state.setHistory = [];
  // fjernet: flagget brukes ikke lenger
  state.allowScoring = false;
  state.nameEditMode = false;
  // Only clear tournament data if not in tournament mode
  if(state.playMode !== 'tournament'){
    state.tournamentData = null;
  }

  const nextSetBtn = document.getElementById('nextSetBtn');
  if(nextSetBtn) nextSetBtn.style.display = 'none';
  const summaryBtn = document.getElementById('showSummaryBtn');
  if(summaryBtn) summaryBtn.style.display = 'none';
  clearWinner();
  closeSummaryModal();
  document.body.classList.remove('areas-active');

  updateEditableState();
  updateScores();
  fitScores();
  saveState();
  
  // ELEGANT: Temporarily disable Firebase reads during reset to prevent race condition
  console.log('[STATE RESET] Temporarily disabling Firebase reads during reset');
  unbindFirebaseSync();
  
  console.log('[STATE RESET] Pushing reset state to Firebase');
  
  const reEnableFirebaseReads = () => {
    console.log('[STATE RESET] Re-enabling Firebase reads');
    if(state.IS_COUNTER) {
      rebindFirebaseWithWriteAccess();
    }
  };
  
  if(typeof pushStateNow === 'function') {
    // Try to use promise-based approach if pushStateNow returns a promise
    const pushResult = pushStateNow();
    if(pushResult && typeof pushResult.then === 'function') {
      // Promise-based - wait for actual completion
      pushResult
        .then(() => {
          console.log('[STATE RESET] Firebase push completed successfully');
          reEnableFirebaseReads();
        })
        .catch((error) => {
          console.warn('[STATE RESET] Firebase push failed, re-enabling reads anyway:', error);
          reEnableFirebaseReads();
        });
    } else {
      // Fallback to timeout if not promise-based
      console.log('[STATE RESET] Using timeout fallback (no promise support)');
      setTimeout(reEnableFirebaseReads, 300); // Slightly longer for safety
    }
  } else {
    // Throttled push fallback
    pushStateThrottled();
    setTimeout(reEnableFirebaseReads, 800); // Longer for throttled
  }
  
  setSplashContinueState({ visible: false });
  
  console.log('[STATE RESET] State after reset:', {
    scoreA: state.scoreA, scoreB: state.scoreB,
    setsA: state.setsA, setsB: state.setsB,
    currentSet: state.currentSet, allowScoring: state.allowScoring
  });
  
  if(skipSplash){
    // Quick start - go directly to name modal
    showNameModal(true);
  } else {
    // Normal flow - show splash
    showSplash();
  }
}

export function finalizeTournamentMatch(options){
  const matchId = state.tournamentData.activeMatchId;
  if(!matchId) return;
  
  const store = state.tournamentData.matchStates || (state.tournamentData.matchStates = {});
  const entry = store[matchId] || (store[matchId] = {
    scoreA: 0, scoreB: 0, setsA: 0, setsB: 0,
    currentSet: 1, setHistory: [], locked: false,
    betweenSets: false, pendingSetWinner: null,
    swappedAt11: false, status: 'pending'
  });
  
  if(options.type === 'played') {
    entry.status = 'completed';
    entry.finalScore = {
      scoreA: state.scoreA,
      scoreB: state.scoreB,
      setsA: state.setsA,
      setsB: state.setsB,
      setHistory: state.setHistory.slice()
    };
  } else if(options.type === 'walkover') {
    entry.status = 'walkover';
    entry.walkoverWinner = options.winnerSide;
    entry.finalScore = null;
  }
  
  state.locked = true;
  state.allowScoring = false;
  
  // Set scroll target for tournament overview
  state.tournamentData.scrollTargetMatchId = matchId;
  
  renderTournamentOverview();
  saveState();
  pushStateThrottled();
  
  // Optionally open overview
  showTournamentOverview();
}

export function startTournamentMatch(matchId){
  // Look up the match in tournament data
  const match = state.tournamentData.matches.find(m => m.id === matchId);
  if(!match) {
    console.log('Match not found:', matchId);
    return;
  }

  // Hide tournament overview and show match view
  hideTournamentOverview();
  showMatch();

  // Set tournament mode and active match
  state.playMode = 'tournament';
  state.tournamentData.activeMatchId = matchId;

  // Rebuild menu with tournament handlers
  menuHandlers = buildMenuHandlers();
  renderMenu(state.VIEW_MODE, menuHandlers);
  
  // Update button visibility for tournament mode
  bindSummaryEvents();
  
  // Update tournament action buttons
  updateTournamentActionButtons();

  // Load or create match state
  const matchState = state.tournamentData.matchStates[matchId];
  if (matchState) {
    // Restore existing match state
    state.scoreA = matchState.scoreA;
    state.scoreB = matchState.scoreB;
    state.setsA = matchState.setsA;
    state.setsB = matchState.setsB;
    state.currentSet = matchState.currentSet;
    state.setHistory = matchState.setHistory;
    state.locked = matchState.locked;
    state.betweenSets = matchState.betweenSets;
    state.pendingSetWinner = matchState.pendingSetWinner;
    state.swappedAt11 = matchState.swappedAt11;
  } else {
    // Create fresh match state
    const fresh = {
      scoreA: 0, scoreB: 0,
      setsA: 0, setsB: 0,
      currentSet: 1,
      setHistory: [],
      locked: false,
      betweenSets: false,
      pendingSetWinner: null,
      swappedAt11: false,
      status: 'pending'
    };
    state.tournamentData.matchStates[matchId] = fresh;
    
    // Initialize state with fresh values
    state.scoreA = fresh.scoreA;
    state.scoreB = fresh.scoreB;
    state.setsA = fresh.setsA;
    state.setsB = fresh.setsB;
    state.currentSet = fresh.currentSet;
    state.setHistory = fresh.setHistory;
    state.locked = fresh.locked;
    state.betweenSets = fresh.betweenSets;
    state.pendingSetWinner = fresh.pendingSetWinner;
    state.swappedAt11 = fresh.swappedAt11;
  }
  
  // fjernet: flagget brukes ikke lenger
  state.allowScoring = false;

  // Hide UI elements
  const nextSetBtn = document.getElementById('nextSetBtn');
  const summaryBtn = document.getElementById('showSummaryBtn');
  if(nextSetBtn) nextSetBtn.style.display = 'none';
  if(summaryBtn) summaryBtn.style.display = 'none';
  
  clearWinner();
  closeSummaryModal();

  // Set player names
  writeModalInputsFromAB(match.playerA || 'Spiller A', match.playerB || 'Spiller B');
  
  // Sync modal values to namesState
  const seededNames = readABFromModalInputs();
  namesState.A = normalizeNameEntry(seededNames.A, 'A', state.matchDiscipline);
  namesState.B = normalizeNameEntry(seededNames.B, 'B', state.matchDiscipline);
  alignNamesState(state.matchDiscipline);
  
  updateNameChips();

  // Mark names as saved and enable scoring
    // fjernet: flagget brukes ikke lenger
  state.allowScoring = true;
  updateEditableState();
  updateScores();
  fitScores();
  saveState();
  pushStateThrottled();
}

function closeSummaryModal(){
  closeModal('#summaryMask');
}

function bindLongPressOne(el, action){
  if(!el) return;
  let timer = 0;
  let startX = 0;
  let startY = 0;
  let down = false;
  let didLong = false;
  let scrollY0 = 0;
  let swallowNextClick = false;

  function vibrate(ms){
    try{ if(navigator.vibrate) navigator.vibrate(ms); }catch(_){ }
  }

  function start(x, y){
    down = true;
    didLong = false;
    startX = x;
    startY = y;
    scrollY0 = window.scrollY;
    clearTimeout(timer);
    timer = setTimeout(function(){
      if(!down || didLong) return;
      didLong = true;
      swallowNextClick = true;
      action();
      vibrate(60);
    }, LONGPRESS_MS);
  }

  function cancel(){
    down = false;
    clearTimeout(timer);
  }

  el.addEventListener('click', function(e){
    if(swallowNextClick){
      swallowNextClick = false;
      e.stopPropagation();
      e.preventDefault();
    }
  }, true);

  el.addEventListener('pointerdown', function(e){
    if(e.pointerType === 'mouse' && e.button !== 0) return;
    if(el.setPointerCapture) el.setPointerCapture(e.pointerId);
    swallowNextClick = false;
    start(e.clientX, e.clientY);
  }, { passive: true });

  el.addEventListener('pointermove', function(e){
    if(!down) return;
    if(Math.hypot(e.clientX - startX, e.clientY - startY) > MOVE_THRESH || Math.abs(window.scrollY - scrollY0) > 2){
      cancel();
    }
  }, { passive: true });

  ['pointerup','pointercancel','pointerleave','lostpointercapture','blur'].forEach(function(evt){
    el.addEventListener(evt, cancel, { passive: true });
  });
}

function bindTap(el, fn){
  if(el) el.addEventListener('click', fn);
}

function maybeShowKebabHint(){
  try{
    if(!localStorage.getItem('badm_kebab_tip_v1')){
      const kebab = document.getElementById('kebab');
      if(kebab){
        kebab.classList.add('pulse');
        setTimeout(function(){
          kebab.classList.remove('pulse');
          localStorage.setItem('badm_kebab_tip_v1', '1');
        }, 2600);
      }
    }
  }catch(_){ }
}

function buildMenuHandlers(){
  return {
    onShare: () => openShare(),
    onNewMatch: () => {
      // Gå til start uten å nullstille state. Oppdater "Fortsett"-knappen live.
      const visible = hasActiveMatchState(state);
      const continueLabel = getContinueLabel(state.playMode);
      try { closeAllModals && closeAllModals(); } catch(_) {}
      setSplashContinueState({ visible, label: continueLabel }); // styrer vis/tekst
      // Oppdater "valgknappene" på splash til dagens mode/disciplin
      syncSplashButtons();
      if (typeof window.updateModalLayout === 'function') window.updateModalLayout();
      showSplash();
    },
    onResetSet: resetSet,
    onSwap: swapSides,
    onEditNames: () => showNameModal(false),
    onClear: () => {
      try{ localStorage.clear(); toast('Lagret data slettet'); }
      catch(_){ toast('Kunne ikke slette'); }
      location.reload();
    },
    onFullscreen: toggleFullscreen,
    onStats: () => renderStats(loadMatches(), mode => { state.VIEW_MODE = mode; }, renderMenu, menuHandlers),
    onTournamentOverview: state.playMode === 'tournament' ? () => showTournamentOverview() : undefined,
    onFinishMatch: state.playMode === 'tournament' ? () => openFinishDialog() : undefined,
    onOpenDashboard: state.playMode === 'tournament' ? () => openDashboard() : undefined,
    onOpenCounter: () => openCounterTab(),
    onClaimWrite: state.IS_COUNTER ? () => {
      if(claimWriteAccess()) {
        toast('Du har nå skrivetilgang');
      } else {
        toast('Du har allerede skrivetilgang');
      }
    } : undefined,
    onReleaseWrite: state.IS_COUNTER ? () => {
      if(releaseWriteAccess()) {
        toast('Skrivetilgang frigitt');
      } else {
        toast('Du har ikke skrivetilgang å frigi');
      }
    } : undefined,
    onBackToMatch: () => {
      showMatch();
      state.VIEW_MODE = 'match';
      renderMenu(state.VIEW_MODE, menuHandlers);
      updateEditableState();
      fitScores();
    }
  };
}

function toggleFullscreen(){
  if(!document.fullscreenElement){
    if(document.documentElement.requestFullscreen) document.documentElement.requestFullscreen();
  }else{
    if(document.exitFullscreen) document.exitFullscreen();
  }
}

function openDashboard(){
  if(!state.tournamentData) return;
  
  // Get game ID from Firebase
  import('../services/firebase.js').then(function(module) {
    var gameId = module.ensureGameId();
    if(!gameId) return;
    
    var url = location.origin + location.pathname + '?mode=dashboard&game=' + encodeURIComponent(gameId);
    window.open(url, '_blank');
  });
}

function openCounterTab(){
  // Get game ID and open new teller tab
  var gameId = ensureGameId();
  if(!gameId) return;
  
  var url = location.origin + location.pathname + '?game=' + encodeURIComponent(gameId);
  window.open(url, '_blank');
}

export function applyRestoredState(){
  updateScores();
  fitScores();
  
  // Rebuild menu for tournament mode after restore
  if(state.playMode === 'tournament' && state.tournamentData){
    menuHandlers = buildMenuHandlers();
    renderMenu(state.VIEW_MODE, menuHandlers);
    updateTournamentActionButtons();
  }
  
  const mask = document.getElementById('summaryMask');
  if(mask && mask.style.display === 'flex') setBodyScroll(false);
}

export function restoreFromStorage(){
  return restoreLiveState({
    writeModalInputsFromNames: names => writeModalInputsFromAB(names.A, names.B),
    updateNameChips,
    setSidesDomTo,
    syncSplashButtons
  });
}

export { updateScores, renderSummary, closeSummaryModal, resetSet, startNewMatch };


--------------------------------------------------
File End
--------------------------------------------------


js\ui\menu.js
File type: .js
﻿import { renderStats } from './statsView.js';
import { loadMatches } from '../services/storage.js';

let kebab;
let panel;
let menuHandlers = {};
let spectatorMode = false;

function ensureElements(){
  if(!kebab) kebab = document.getElementById('kebab');
  if(!panel) panel = document.getElementById('menuPanel');
}

export function setupMenu(options){
  options = options || {};
  spectatorMode = !!options.isSpectator;
  ensureElements();
  if(!kebab || !panel) return;

  kebab.addEventListener('click', function(e){
    e.stopPropagation();
    togglePanel();
  });

  document.addEventListener('click', function(e){
    if(!panel.contains(e.target) && e.target !== kebab) closePanel();
  });

  document.addEventListener('keydown', function(e){
    if(e.key === 'Escape') closePanel();
  });
}

export function renderMenu(mode, handlers){
  menuHandlers = handlers || {};
  
  // Add stats handler if not provided
  if (!menuHandlers.onStats) {
    menuHandlers.onStats = function(){
      try {
        const matches = loadMatches();
        renderStats(matches, function(mode) { 
          // Mode change callback - could update state.VIEW_MODE if needed
        }, null, null);
      } catch(e) {
        console && console.error && console.error('Stats open error', e);
      }
    };
  }
  
  ensureElements();
  if(!kebab || !panel) return;

  if(spectatorMode){
    kebab.style.display = 'none';
    panel.style.display = 'none';
    return;
  }

  kebab.style.display = 'block';

  var html = '';
  if(mode === 'match'){
    html += menuItem('miNewMatch', '🏠 Til start', menuHandlers.onNewMatch);
    html += menuItem('miShare', '🔗 Del…', menuHandlers.onShare);
    html += menuItem('miOpenCounter', '📱 Åpne teller i ny fane', menuHandlers.onOpenCounter);
    html += menuItem('miTournamentOverview', '📋 Kampoversikt', menuHandlers.onTournamentOverview);
    html += menuItem('miOpenDashboard', '📺 Åpne kampoversikt i ny fane', menuHandlers.onOpenDashboard);
    html += menuItem('miFinishMatch', '✅ Ferdigstill kamp', menuHandlers.onFinishMatch);
    html += menuItem('miResetSet', '♻️ Nullstill sett', menuHandlers.onResetSet);
    html += menuItem('miSwap', '⇄ Bytt side', menuHandlers.onSwap);
    html += '<div class="menuHR"></div>';
    html += menuItem('miClaimWrite', '✋ Ta kontroll', menuHandlers.onClaimWrite);
    html += menuItem('miReleaseWrite', '🤝 Frigi kontroll', menuHandlers.onReleaseWrite);
    html += '<div class="menuHR"></div>';
    html += menuItem('miEditNames', '✏️ Rediger spillernavn', menuHandlers.onEditNames);
    html += menuItem('miClearStorage', '🗑️ Nullstill lagret data', menuHandlers.onClear);
    html += menuItem('miFullscreen', '⛶ Fullskjerm', menuHandlers.onFullscreen);
    html += menuItem('miStats', '📊 Vis statistikk', menuHandlers.onStats);
  }else if(mode === 'stats'){
    html += menuItem('miBackToMatch', '↩︎ Vis kamp', menuHandlers.onBackToMatch);
    html += '<div class="menuHR"></div>';
    html += menuItem('miFullscreen', '⛶ Fullskjerm', menuHandlers.onFullscreen);
    html += menuItem('miClearStorage', '🗑️ Nullstill lagret data', menuHandlers.onClear);
  }

  panel.innerHTML = html;
  bindMenuItems();
}

function menuItem(id, label, handler){
  if(typeof handler !== 'function'){
    return '';
  }
  return '<div class="menuItem" id="'+id+'" role="menuitem">'+label+'</div>';
}

function bindMenuItems(){
  Object.keys(menuHandlers || {}).forEach(function(key){
    var id = handlerIdFor(key);
    if(!id) return;
    var el = document.getElementById(id);
    if(el && typeof menuHandlers[key] === 'function'){
      el.addEventListener('click', function(){
        closePanel();
        menuHandlers[key]();
      });
    }
  });
}

function handlerIdFor(key){
  switch(key){
    case 'onShare': return 'miShare';
    case 'onNewMatch': return 'miNewMatch';
    case 'onResetSet': return 'miResetSet';
    case 'onSwap': return 'miSwap';
    case 'onEditNames': return 'miEditNames';
    case 'onClear': return 'miClearStorage';
    case 'onFullscreen': return 'miFullscreen';
    case 'onStats': return 'miStats';
    case 'onTournamentOverview': return 'miTournamentOverview';
    case 'onFinishMatch': return 'miFinishMatch';
    case 'onBackToMatch': return 'miBackToMatch';
    case 'onOpenDashboard': return 'miOpenDashboard';
    case 'onOpenCounter': return 'miOpenCounter';
    case 'onClaimWrite': return 'miClaimWrite';
    case 'onReleaseWrite': return 'miReleaseWrite';
    default: return null;
  }
}

function togglePanel(){
  ensureElements();
  if(!panel) return;
  panel.style.display = (panel.style.display === 'block') ? 'none' : 'block';
}

export function closePanel(){
  ensureElements();
  if(panel) panel.style.display = 'none';
}





--------------------------------------------------
File End
--------------------------------------------------


js\ui\modal.js
File type: .js
// js/ui/modal.js
import { setBodyScroll } from '../dom.js';

// Finn fokusbare elementer inne i en modal
function focusables(root) {
  return Array.from(root.querySelectorAll(
    'a[href], button:not([disabled]), textarea, input, select, [tabindex]:not([tabindex="-1"])'
  )).filter(el => el.offsetParent !== null || el.getClientRects().length);
}

function resolve(elOrId){
  if(!elOrId) return null;
  return (typeof elOrId === 'string') ? document.querySelector(elOrId) : elOrId;
}

export function openModal(id, opts){
  const mask = resolve(id);
  if(!mask) return;
  const display = (opts && opts.display) || 'flex';
  const trap = (opts && opts.trap) !== false; // default true
  const focusSel = opts && opts.focus;
  const closeOnBackdrop = !!(opts && opts.closeOnBackdrop);
  const closeOnEsc = (opts && 'closeOnEsc' in opts) ? !!opts.closeOnEsc : true;

  // Vis
  mask.style.display = display;
  if (mask.classList) mask.classList.add('show');
  mask.setAttribute('aria-hidden', 'false');
  setBodyScroll(false);

  // Lagre forrige fokus
  mask.__prevFocus = document.activeElement || null;

  // Sett startfokus
  let first = null;
  if(focusSel) first = mask.querySelector(focusSel);
  if(!first){
    const list = focusables(mask);
    first = list[0] || mask;
  }
  try { first.focus(); } catch(_) {}

  if(trap){
    // Enkel fokusfelle
    const onKey = (e) => {
      if(e.key !== 'Tab') return;
      const items = focusables(mask);
      if(items.length === 0) return;
      const firstEl = items[0];
      const lastEl  = items[items.length - 1];
      if(e.shiftKey && document.activeElement === firstEl){
        e.preventDefault(); lastEl.focus();
      }else if(!e.shiftKey && document.activeElement === lastEl){
        e.preventDefault(); firstEl.focus();
      }
    };
    mask.__trapHandler = onKey;
    mask.addEventListener('keydown', onKey);
  }

  // Backdrop-klikking
  if(closeOnBackdrop){
    const onBackdrop = (e) => { if(e.target === mask) closeModal(mask); };
    mask.__backdropHandler = onBackdrop;
    mask.addEventListener('click', onBackdrop);
  }

  // Escape
  if(closeOnEsc){
    const onEsc = (e) => {
      if(e.key === 'Escape'){
        e.preventDefault();
        closeModal(mask);
      }
    };
    mask.__escHandler = onEsc;
    document.addEventListener('keydown', onEsc);
  }
}

export function closeModal(id){
  const mask = resolve(id);
  if(!mask) return;
  // Skru av fokusfelle
  if(mask.__trapHandler){
    mask.removeEventListener('keydown', mask.__trapHandler);
    delete mask.__trapHandler;
  }
  if(mask.__backdropHandler){
    mask.removeEventListener('click', mask.__backdropHandler);
    delete mask.__backdropHandler;
  }
  if(mask.__escHandler){
    document.removeEventListener('keydown', mask.__escHandler);
    delete mask.__escHandler;
  }
  // Skjul
  if (mask.classList) mask.classList.remove('show');
  mask.style.display = 'none';
  mask.setAttribute('aria-hidden', 'true');
  setBodyScroll(true);
  // Gjenopprett fokus
  try { mask.__prevFocus && mask.__prevFocus.focus(); } catch(_) {}
  delete mask.__prevFocus;
}


--------------------------------------------------
File End
--------------------------------------------------


js\ui\namesModal.js
File type: .js
import { state, getDisplayName } from '../state/matchState.js';
import { setBodyScroll, $ } from '../dom.js';
import { openModal, closeModal } from './modal.js';
import { saveLastNames, getRecentNames } from '../services/storage.js';
import { saveIndividual, saveFromAB } from '../services/namesStore.js';
import { readABFromModalInputs, writeModalInputsFromAB, updateNameChipsFromModal } from './layout.js';
import { attachAutocomplete, toggleDropdownFor, updateDropdownButtons } from './autocomplete.js';
import { isAtStart } from './session.js';
import { qs } from '../util/domUtils.js';


export function updateModalLayout(){
  const singleNames = $('#singleNames');
  const doubleNames = $('#doubleNames');
  const nameCard = $('.nameCard');
  
  if(state.matchDiscipline === 'double'){
    if(singleNames) singleNames.style.display = 'none';
    if(doubleNames) doubleNames.style.display = 'grid';
    if(nameCard) nameCard.classList.add('double');
  } else {
    if(singleNames) singleNames.style.display = 'grid';
    if(doubleNames) doubleNames.style.display = 'none';
    if(nameCard) nameCard.classList.remove('double');
  }
}

export function showNameModal(startMode){
  state.nameEditMode = true;
  state.allowScoring = false;
  renderRecentOptions();
  
  // Show/hide appropriate name fields based on discipline
  updateModalLayout();
  
  // Update dropdown button visibility based on available names
  updateDropdownButtons('#nameMask');
  
  openModal('#nameMask', {
    focus: state.matchDiscipline === 'double' ? '#teamNameA' : '#nameA'
  });

  // Load current names into modal
  const currentNames = readABFromModalInputs();
  writeModalInputsFromAB(currentNames.A, currentNames.B);
  updateNameChips();

  var startBtn = $('#btnStart');
  var saveBtn = $('#btnSaveNames');
  if(startMode){
    if(startBtn) startBtn.style.display = 'inline-block';
    if(saveBtn) saveBtn.style.display = 'none';
  }else{
    if(startBtn) startBtn.style.display = 'none';
    if(saveBtn) saveBtn.style.display = 'inline-block';
  }
}

export function hideNameModal(){
  state.nameEditMode = false;
  closeModal('#nameMask');
  updateEditableState();
}

export function updateEditableState(){
  var atStart = isAtStart(state);
  if(!state.IS_SPECTATOR && (atStart || state.nameEditMode) && !state.allowScoring){
    document.body.classList.remove('areas-active');
  }else if(!state.IS_SPECTATOR){
    document.body.classList.add('areas-active');
  }
  if(!state.IS_SPECTATOR) updateNameChips();
}

export function updateNameChips(){
  if(state.IS_SPECTATOR) return;
  updateNameChipsFromModal();
}

export function renderRecentOptions(){
  // Autocomplete dropdown handles this dynamically.
}

export function autocomplete(input, listId){
  const listEl = qs('#' + listId);
  if(!listEl) return;
  
  attachAutocomplete(input, {
    listEl,
    onSelect: () => {
      updateNameChips();
      updateDropdownButtons('#nameMask');
    }
  });
}

export function toggleDropdown(fieldId){
  const input = qs('#' + fieldId);
  const list = qs('#' + fieldId + '-list');
  const btn = input?.parentElement?.querySelector('.dropdown-btn');
  
  if(!input || !list || (btn && btn.classList.contains('hidden'))) return;
  
  toggleDropdownFor(input, list, () => getRecentNames(8));
}

export function onSaveNames(saveLiveState, pushStateThrottled){
  var names = readABFromModalInputs();
  
  // Extract display names for saving to localStorage
  const aDisplay = getDisplayName(names.A, 'A');
  const bDisplay = getDisplayName(names.B, 'B');
  
  saveLastNames(aDisplay, bDisplay);
  
  // lagre alle relevante navn via helper
  saveFromAB(names, state.matchDiscipline);
  
  hideNameModal();
  updateNameChips();
  updateDropdownButtons('#nameMask'); // oppdater lokalt innenfor modal
  state.allowScoring = true;
  if(typeof saveLiveState === 'function') saveLiveState();
  if(typeof pushStateThrottled === 'function') pushStateThrottled();
}

window.toggleDropdown = toggleDropdown;
window.updateModalLayout = updateModalLayout;


--------------------------------------------------
File End
--------------------------------------------------


js\ui\session.js
File type: .js
// js/ui/session.js
// Felles, ren og testbar hjelp for "aktiv kamp?" og "Fortsett"-etikett.

export function hasActiveMatchState(state){
  if(!state) return false;
  return !!(state.allowScoring ||
    state.scoreA > 0 ||
    state.scoreB > 0 ||
    state.setsA > 0 ||
    state.setsB > 0 ||
    (Array.isArray(state.setHistory) && state.setHistory.length > 0) ||
    state.betweenSets ||
    state.locked);
}

export function getContinueLabel(playMode){
  return playMode === 'tournament'
    ? 'Fortsett pågående turnering'
    : 'Fortsett pågående kamp';
}

// Ny: felles helper for "er vi ved helt fersk start av kamp?"
export function isAtStart(state){
  if(!state) return false;
  return (
    state.scoreA === 0 &&
    state.scoreB === 0 &&
    state.setsA === 0 &&
    state.setsB === 0 &&
    state.currentSet === 1 &&
    !state.locked
  );
}


--------------------------------------------------
File End
--------------------------------------------------


js\ui\share.js
File type: .js
import { toast } from '../dom.js';
import { openModal, closeModal } from './modal.js';
import { loadScriptOnce } from '../util/loadScript.js';

let getShareUrl = function(){ return location.href; };
let qrReady = false;
let qrLoading = false;
let currentRole = 'spectator'; // Default role

export function initShare(options){
  options = options || {};
  if(typeof options.getShareUrl === 'function') getShareUrl = options.getShareUrl;

  var closeBtn = document.getElementById('shareClose');
  if(closeBtn) closeBtn.addEventListener('click', closeShare);

  var copyBtn = document.getElementById('btnCopy');
  if(copyBtn) copyBtn.addEventListener('click', copyLink);

  var openSpectator = document.getElementById('btnOpenSpectator');
  if(openSpectator) openSpectator.addEventListener('click', function(){
    window.open(getCurrentShareUrl(), '_blank');
  });

  var webShare = document.getElementById('btnWebShare');
  if(webShare){
    if(navigator.share){
      webShare.style.display = 'inline-block';
      webShare.addEventListener('click', function(){
        var title = currentRole === 'spectator' ? 'Tilskuervy' : 
                     currentRole === 'cocounter' ? 'Medteller' : 'Teller';
        navigator.share({
          title: title,
          text: 'Badminton teller',
          url: getCurrentShareUrl()
        }).catch(function(){});
      });
    }else{
      webShare.style.display = 'none';
    }
  }

  // Setup role toggle listeners
  setupRoleToggle();
}

function setupRoleToggle(){
  var roleInputs = document.querySelectorAll('input[name="shareRole"]');
  roleInputs.forEach(function(input){
    input.addEventListener('change', function(){
      if(this.checked){
        currentRole = this.value;
        updateShareContent();
      }
    });
  });
}

function getCurrentShareUrl(){
  var baseUrl = getShareUrl();
  var url = new URL(baseUrl);
  
  // Set mode parameter based on current role
  url.searchParams.set('mode', currentRole);
  
  return url.toString();
}

function updateShareContent(){
  var url = getCurrentShareUrl();
  var urlEl = document.getElementById('shareUrl');
  var openBtn = document.getElementById('btnOpenSpectator');
  
  if(urlEl) urlEl.textContent = url;
  
  // Update button text based on role
  if(openBtn) {
    var btnText = currentRole === 'spectator' ? 'Åpne tilskuer' : 
                  currentRole === 'cocounter' ? 'Åpne medteller' : 'Åpne teller';
    openBtn.textContent = btnText;
  }
  
  // Regenerate QR code with new URL
  var box = document.getElementById('qrBox');
  if(box) {
    box.innerHTML = '';
    if(window.QRCode){
      new QRCode(box, {
        text: url,
        width: 280,
        height: 280,
        colorDark: '#ffffff',
        colorLight: '#0f172a',
        correctLevel: QRCode.CorrectLevel.Q
      });
    }
  }
}

export function openShare(){
  // Reset to default role when opening
  currentRole = 'spectator';
  var spectatorRadio = document.querySelector('input[name="shareRole"][value="spectator"]');
  if(spectatorRadio) spectatorRadio.checked = true;
  
  updateShareContent();
  
  var box = document.getElementById('qrBox');
  if(box) box.innerHTML = '';

  ensureQrLib(function(err){
    if(!err && window.QRCode){
      updateShareContent(); // This will generate QR code
    }else if(box){
      box.innerHTML = '<div style="color:#fbbf24;text-align:center">QR utilgjengelig ? bruk lenken under.</div>';
    }
    openModal('#shareMask', { closeOnBackdrop: true, closeOnEsc: true });
  });
}

export function closeShare(){
  closeModal('#shareMask');
}

function ensureQrLib(cb){
  if(qrReady){
    cb(null);
    return;
  }
  if(qrLoading){
    var timer = setInterval(function(){
      if(qrReady){
        clearInterval(timer);
        cb(null);
      }
    }, 100);
    return;
  }
  qrLoading = true;
  loadScriptOnce('https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js')
    .then(function(){
      qrReady = !!window.QRCode;
      qrLoading = false;
      cb(null);
    })
    .catch(function(err){
      qrReady = false;
      qrLoading = false;
      cb(err);
    });
}

// loadScriptOnce moved to js/util/loadScript.js

function copyLink(){
  var url = getCurrentShareUrl();
  if(navigator.clipboard && window.isSecureContext){
    navigator.clipboard.writeText(url).then(function(){ 
      var toastMsg = currentRole === 'spectator' ? 'Tilskuer-lenke kopiert' : 
                     currentRole === 'cocounter' ? 'Medteller-lenke kopiert' : 'Teller-lenke kopiert';
      toast(toastMsg); 
    });
  }else{
    try{
      var ta = document.createElement('textarea');
      ta.value = url;
      ta.style.position = 'fixed';
      ta.style.top = '-1000px';
      document.body.appendChild(ta);
      ta.focus();
      ta.select();
      document.execCommand('copy');
      document.body.removeChild(ta);
      var toastMsg = currentRole === 'spectator' ? 'Tilskuer-lenke kopiert' : 
                     currentRole === 'cocounter' ? 'Medteller-lenke kopiert' : 'Teller-lenke kopiert';
      toast(toastMsg);
    }catch(_){
      toast('Kopier mislyktes');
    }
  }
}


--------------------------------------------------
File End
--------------------------------------------------


js\ui\splash.js
File type: .js
import { state, clearLiveState } from '../state/matchState.js';
import { $ } from '../dom.js';
import { hasActiveMatchState, getContinueLabel } from './session.js';
import { openModal, closeModal } from './modal.js';

let splashMask;
let splashStartBtn;
let splashContinueBtn;
let disciplineButtons = [];
let modeButtons = [];
let startCallback = function(){};
let saveState = function(){};
// Confirm modal elements
let confirmMask, confirmOk, confirmCancel, confirmClose, confirmText;

// Bruk felles helper fra session.js

function hasActiveTournamentState(){
  return !!(state && state.tournamentData && !state.tournamentData.archived);
}

function hasActiveTournament(){
  // Sjekk faktisk aktiv turnering (ikke bare toggle)
  return !!(state && state.tournamentData && 
    state.tournamentData.name && 
    state.tournamentData.matches && 
    state.tournamentData.matches.length > 0 &&
    !state.tournamentData.archived);
}

function shouldShowContinue(){
  return hasActiveMatchState(state) || hasActiveTournamentState();
}

function ensureElements(){
  if(!splashMask) splashMask = document.getElementById('splashMask');
  if(!splashStartBtn) splashStartBtn = document.getElementById('splashStartBtn');
  if(!splashContinueBtn) splashContinueBtn = document.getElementById('splashContinueBtn');
  if(!disciplineButtons.length && splashMask) disciplineButtons = Array.from(splashMask.querySelectorAll('[data-discipline]'));
  if(!modeButtons.length && splashMask) modeButtons = Array.from(splashMask.querySelectorAll('[data-mode]'));
  // confirm modal bits
  if(!confirmMask) confirmMask = document.getElementById('confirmStartMask');
  if(!confirmOk) confirmOk = document.getElementById('confirmStartOk');
  if(!confirmCancel) confirmCancel = document.getElementById('confirmStartCancel');
  if(!confirmClose) confirmClose = document.getElementById('confirmStartClose');
  if(!confirmText) confirmText = document.getElementById('confirmStartText');
  return !!splashMask;
}

function openConfirmStart(onConfirm){
  if(!confirmMask) return onConfirm && onConfirm(false);
  // Sett rett tekst basert på faktisk aktiv state (ikke toggle)
  const isActiveTournament = hasActiveTournament();
  const message = isActiveTournament
    ? 'Dette vil avslutte og slette pågående turnering (alle kamper og resultater). Fortsette?'
    : 'Dette vil avslutte og slette pågående enkeltkamp. Fortsette?';
  if(confirmText) confirmText.textContent = message;

  // Fjern gamle lyttere (om noen) og bind på nytt
  if(confirmOk){ 
    confirmOk.onclick = () => { 
      closeModal('#confirmStartMask'); 
      
      // Clear all state before starting new match/tournament
      try { clearLiveState(); } catch(_) {}
      state.tournamentData = null;
      if (state.ui) state.ui.nextNavHint = null;
      setSplashContinueState({ visible: false });
      
      onConfirm && onConfirm(true); 
    }; 
  }
  if(confirmCancel){ confirmCancel.onclick = () => { closeModal('#confirmStartMask'); onConfirm && onConfirm(false); }; }
  if(confirmClose){ confirmClose.onclick = () => { closeModal('#confirmStartMask'); onConfirm && onConfirm(false); }; }

  openModal('#confirmStartMask', { closeOnBackdrop: true, closeOnEsc: true, focus: '#confirmStartCancel' });
}

function updateSplashButtons(){
  var showContinue = shouldShowContinue();
  if (splashContinueBtn){
    splashContinueBtn.style.display = showContinue ? '' : 'none';
    splashContinueBtn.disabled = !showContinue;
  }
}

export function setupSplash(options){
  options = options || {};
  startCallback = typeof options.onStart === 'function' ? options.onStart : startCallback;
  saveState = typeof options.saveState === 'function' ? options.saveState : saveState;
  if(!ensureElements()) return;
  if(splashMask.dataset.bound) return;
  splashMask.dataset.bound = '1';

  updateSplashButtons();
  if (state.ui && state.ui.requestSplashButtonsRefresh) {
    updateSplashButtons();
    state.ui.requestSplashButtonsRefresh = false;
  }

  syncSplashButtons();

  disciplineButtons.forEach(function(btn){
    btn.addEventListener('click', function(){
      var value = btn.getAttribute('data-discipline');
      if(!value || state.matchDiscipline === value) return;
      state.matchDiscipline = value;
      syncSplashButtons();
      saveState();
      
      // Update modal layout when discipline changes
      if(typeof window.updateModalLayout === 'function'){
        window.updateModalLayout();
      }
    });
  });

  modeButtons.forEach(function(btn){
    btn.addEventListener('click', function(){
      var value = btn.getAttribute('data-mode');
      if(!value || state.playMode === value) return;
      state.playMode = value;
      syncSplashButtons();
      saveState();
    });
  });

  if(splashStartBtn){
    splashStartBtn.addEventListener('click', function(){
      if(splashStartBtn.disabled) return;
      splashStartBtn.disabled = true;
      // Bekreft hvis dette potensielt sletter pågående data – pen modal
      if (hasActiveMatchState(state)) {
        openConfirmStart(function(ok){
          if(!ok){ splashStartBtn.disabled = false; return; }
          hideSplash();
          startCallback({ fromSplash: true });
          setTimeout(function(){ splashStartBtn.disabled = false; }, 400);
        });
      } else {
        hideSplash();
        startCallback({ fromSplash: true });
        setTimeout(function(){ splashStartBtn.disabled = false; }, 400);
      }
    });
  }
  if(splashContinueBtn){
    splashContinueBtn.addEventListener('click', function(){
      if(splashContinueBtn.disabled) return;
      splashContinueBtn.disabled = true;
      hideSplash();
      
      // Set navigation hint for tournament mode
      if(state.playMode === 'tournament'){
        state.ui.nextNavHint = 'continueTournament';
      }
      
      startCallback({ fromSplash: true, continueMatch: true, skipSplash: true, restored: true });
      setTimeout(function(){ splashContinueBtn.disabled = false; }, 400);
    });
  }
}

export function syncSplashButtons(){
  if(!ensureElements()) return;
  disciplineButtons.forEach(function(btn){
    var active = btn.getAttribute('data-discipline') === state.matchDiscipline;
    btn.classList.toggle('active', active);
    btn.setAttribute('aria-pressed', active ? 'true' : 'false');
  });
  modeButtons.forEach(function(btn){
    var active = btn.getAttribute('data-mode') === state.playMode;
    btn.classList.toggle('active', active);
    btn.setAttribute('aria-pressed', active ? 'true' : 'false');
  });
}

export function showSplash(){
  if(!ensureElements()) return;
  splashMask.classList.add('show');
  splashMask.setAttribute('aria-hidden', 'false');
  document.body.classList.add('splash-open');
  document.body.classList.remove('areas-active');
}

export function hideSplash(){
  if(!ensureElements()) return;
  splashMask.classList.remove('show');
  splashMask.setAttribute('aria-hidden', 'true');
  document.body.classList.remove('splash-open');
}

export function setSplashContinueState(options){
  if(!ensureElements()) return;
  const visible = !!(options && options.visible);
  if(splashContinueBtn){
    splashContinueBtn.style.display = visible ? 'block' : 'none';
    splashContinueBtn.setAttribute('aria-hidden', visible ? 'false' : 'true');
    splashContinueBtn.tabIndex = visible ? 0 : -1;
    if(options && options.label){
      splashContinueBtn.textContent = options.label;
    }
  }
}


--------------------------------------------------
File End
--------------------------------------------------


js\ui\statsView.js
File type: .js
﻿import { state } from '../state/matchState.js';
import { loadMatches, saveMatches } from '../services/storage.js';
import { fitScores } from './layout.js';
// (fjernet ubrukte imports)
import { openModal, closeModal } from './modal.js';

let lastRenderMenu = null;
let lastHandlers = null;
let onModeChange = null;

function ensureStatsShell(){
  var panelBody = document.getElementById('statsPanelBody');
  if(!panelBody) return null;
  
  // Check if it only contains the placeholder comment
  const hasOnlyComment = panelBody.children.length === 0 && panelBody.innerHTML.includes('Stats content will be rendered here');
  
  if(!panelBody.hasChildNodes() || hasOnlyComment) {
    panelBody.innerHTML = '<h3>Alle kamper & oversikt</h3>'+
      '<div id="stats" class="stats"></div>'+
      '<div id="leaderboard"></div>'+
      '<div style="height:.6rem"></div>'+
      '<table>'+
        '<thead><tr><th>#</th><th>Dato</th><th>Spiller A</th><th>Spiller B</th><th>Sett</th><th>Vinner</th><th>Handling</th></tr></thead>'+
        '<tbody id="historyBody"></tbody>'+
      '</table>';
  }
  return panelBody;
}

export function fmtStats(matches){
  var stats = {
    matches: matches.length,
    sets: 0,
    straight: 0,
    three: 0,
    deuceSets: 0,
    avgMargin: 0,
    maxTotalSet: null
  };
  var marginSum = 0;

  matches.forEach(function(match){
    var sets = match.sets || [];
    stats.sets += sets.length;
    var wins = [0,0];

    sets.forEach(function(set){
      var a = +set.a || 0;
      var b = +set.b || 0;
      if(a > b) wins[0]++; else wins[1]++;
      var total = a + b;
      var margin = Math.abs(a - b);
      marginSum += margin;
      if(a >= 20 && b >= 20) stats.deuceSets++;
      if(!stats.maxTotalSet || total > (stats.maxTotalSet.a + stats.maxTotalSet.b)){
        stats.maxTotalSet = { a: a, b: b, names: match.names };
      }
    });

    if(wins[0] === 2 || wins[1] === 2) stats.straight++;
    else stats.three++;
  });

  stats.avgMargin = stats.sets ? (marginSum / stats.sets) : 0;
  return stats;
}

export function renderStats(matches, modeChangeCb, renderMenuFn, handlers){
  matches = matches || loadMatches();
  onModeChange = modeChangeCb;
  lastRenderMenu = renderMenuFn || lastRenderMenu;
  lastHandlers = handlers || lastHandlers;

  let host = ensureStatsShell();
  if(!host){
    // init én gang og prøv igjen
    try { 
      if (typeof setupStatsModal === 'function') setupStatsModal(); 
    } catch(_) {}
    host = ensureStatsShell();
    if(!host){
      // siste fallback: logg og vis noe synlig
      console && console.warn && console.warn('statsPanelBody missing');
      const mask = document.getElementById('statsMask');
      if (mask) openModal('#statsMask');
      return;
    }
  }
  
  try {
    // Show stats modal
    openModal('#statsMask');

    state.VIEW_MODE = 'stats';
    document.body.classList.add('stats-mode');

    // Exit match view - remove event listeners
    import('./matchView.js').then(function(module) {
      if(module.exitMatch) module.exitMatch();
    });

    if(typeof onModeChange === 'function') onModeChange('stats');
    if(lastRenderMenu) lastRenderMenu('stats', lastHandlers);

    var stats = fmtStats(matches);
    
    var statsContainer = document.getElementById('stats');
    if(statsContainer){
      statsContainer.innerHTML = '';
      statsContainer.appendChild(statCard('Kamper lagret', stats.matches));
      statsContainer.appendChild(statCard('Sett spilt', stats.sets));
      statsContainer.appendChild(statCard('2-0-kamper', stats.straight));
      statsContainer.appendChild(statCard('3-settskamper', stats.three));
      statsContainer.appendChild(statCard('Deuce-sett (≥20–20)', String(stats.deuceSets)));
      statsContainer.appendChild(statCard('Snitt seiersmargin/sett', stats.avgMargin.toFixed(2)));
      if(stats.maxTotalSet){
        statsContainer.appendChild(statCard('Høyest poeng i ett sett', stats.maxTotalSet.a + '-' + stats.maxTotalSet.b));
      }
    }

  var leaderDiv = document.getElementById('leaderboard');
  if(leaderDiv){
    leaderDiv.innerHTML = '<h4 style="margin:.2rem 0 .4rem 0">Seiersoversikt</h4>';
    var winMap = {};
    matches.forEach(function(match){
      var w = match.winner || '';
      winMap[w] = (winMap[w] || 0) + 1;
    });
    var entries = Object.keys(winMap).map(function(name){
      return [name, winMap[name]];
    }).sort(function(a,b){ return b[1] - a[1]; });
    if(!entries.length){
      leaderDiv.appendChild(document.createTextNode('Ingen lagrede kamper ennå.'));
    }else{
      var cont = document.createElement('div');
      cont.className = 'leader';
      entries.forEach(function(entry){
        var name = document.createElement('div');
        name.textContent = entry[0];
        var count = document.createElement('div');
        count.textContent = entry[1];
        count.style.textAlign = 'right';
        cont.appendChild(name);
        cont.appendChild(count);
      });
      leaderDiv.appendChild(cont);
    }
  }

  var body = document.getElementById('historyBody');
  if(body){
    body.innerHTML = '';
    matches.forEach(function(match, idx){
      var tr = document.createElement('tr');
      function td(txt){
        var cell = document.createElement('td');
        cell.textContent = txt;
        return cell;
      }
      tr.appendChild(td(String(idx + 1)));
      tr.appendChild(td(formatDate(match.ts)));
      tr.appendChild(td(match.names?.A || 'Spiller A'));
      tr.appendChild(td(match.names?.B || 'Spiller B'));
      var parts = (match.sets || []).map(function(set){
        return String(set.a) + '-' + String(set.b);
      });
      tr.appendChild(td(parts.join(' , ')));
      tr.appendChild(td(match.winner || ''));

      var tdAct = document.createElement('td');
      var del = document.createElement('button');
      del.className = 'button';
      del.textContent = 'Slett';
      del.addEventListener('click', function(){
        var arr = loadMatches();
        arr.splice(idx, 1);
        saveMatches(arr);
        renderStats(arr, onModeChange, lastRenderMenu, lastHandlers);
      });
      tdAct.appendChild(del);
      tr.appendChild(tdAct);
      body.appendChild(tr);
    });
  }
  } catch (err) {
    console && console.error && console.error('renderStats failed', err);
    if (host) {
      host.innerHTML = '<div class="statsError">Kunne ikke generere statistikk akkurat nå.</div>';
    }
  }
}

export function showMatch(){
  // Hide stats modal
  closeModal('#statsMask');

  state.VIEW_MODE = 'match';
  document.body.classList.remove('stats-mode');
  if(typeof onModeChange === 'function') onModeChange('match');
  if(lastRenderMenu) lastRenderMenu('match', lastHandlers);

  // Enter match view - bind event listeners
  import('./matchView.js').then(function(module) {
    if(module.enterMatch) module.enterMatch();
  });

  fitScores();
}

export function setupStatsModal(){
  const closeBtn = document.getElementById('statsClose');
  const mask = document.getElementById('statsMask');
  
  if(closeBtn) {
    closeBtn.addEventListener('click', showMatch);
  }
  
  if(mask) {
    mask.addEventListener('click', function(e) {
      if(e.target === mask) showMatch();
    });
  }
}

function statCard(label, value){
  var card = document.createElement('div');
  card.className = 'stat';
  card.innerHTML = '<div class="muted">'+label+'</div>'+
    '<div style="font-size:1.15rem;font-weight:700">'+value+'</div>';
  return card;
}

function formatDate(ts){
  var d = new Date(ts || Date.now());
  return d.toLocaleString(undefined, {
    year: 'numeric',
    month: '2-digit',
    day: '2-digit',
    hour: '2-digit',
    minute: '2-digit'
  });
}





--------------------------------------------------
File End
--------------------------------------------------


js\ui\tournamentOverview.js
File type: .js
import { state } from '../state/matchState.js';
// (fjernet ubrukte imports)
import { openModal, closeModal } from './modal.js';
import { hasActiveMatchState, getContinueLabel } from './session.js';
import { showSplash, setSplashContinueState, syncSplashButtons } from './splash.js';
import { goToStart } from '../main.js';
import { updateScores } from './matchView.js';

// Konfig: når turneringen låses (må matche tournamentSetup.js)
const TOURNAMENT_LOCK_MODE = 'onCreation'; // 'onCreation' | 'onFirstMatch'


let mask;
let modal;
let titleElement;
let nameElement;
let closeBtn;
let backBtn;
let startBtn;

function ensureElements(){
  if(!mask) mask = document.getElementById('tournamentOverviewMask');
  if(!mask) return false;
  if(!modal) modal = mask.querySelector('.tournamentOverviewPanel');
  if(!titleElement) titleElement = document.getElementById('tournamentOverviewTitle');
  if(!nameElement) nameElement = document.getElementById('tournamentOverviewName');
  if(!closeBtn) closeBtn = document.getElementById('tournamentOverviewClose');
  if(!backBtn) backBtn = document.getElementById('tournamentOverviewBack');
  if(!startBtn) startBtn = document.getElementById('tournamentOverviewStart');
  return true;
}

function bindEvents(){
  if(!ensureElements()) return;
  if(mask.dataset.bound) return;
  mask.dataset.bound = '1';

  if(closeBtn){
    closeBtn.addEventListener('click', function(){
      hideTournamentOverview();
      goToStart({ from: 'overview' });
    });
  }

  if(backBtn){
    backBtn.addEventListener('click', function(){
      // Guard: blokker tilbake-navigasjon når turneringen er låst
      if(state.tournamentData && state.tournamentData.locked){
        // Avskjær forsøk på å gå tilbake til setup når låst
        return;
      }
      hideTournamentOverview();
      // Import and show tournament setup
      import('./tournamentSetup.js').then(function(module){
        module.showTournamentSetup();
      });
    });
  }

  if(startBtn){
    startBtn.addEventListener('click', function(){
      hideTournamentOverview();
      startFirstMatch();
    });
  }
}

export function showTournamentOverview(){
  if(!ensureElements()) return;
  
  // Ensure we have tournament data
  if(!state.tournamentData || !state.tournamentData.name){
    console.error('No tournament data available');
    return;
  }

  state.allowScoring = false;
  document.body.classList.remove('areas-active');

  // Set the tournament name dynamically
  nameElement.textContent = state.tournamentData.name;

  // Hide/disable back button when tournament is locked
  if(backBtn){
    if(state.tournamentData.locked){
      backBtn.style.display = 'none';
    } else {
      backBtn.style.display = '';
    }
  }

  openModal('#tournamentOverviewMask');

  if (startBtn) {
    const matches = state.tournamentData?.matches || [];
    const matchStates = state.tournamentData?.matchStates || {};
    const hasPending = matches.some(m => {
      const st = matchStates[m.id];
      return !st || (st.status !== 'completed' && st.status !== 'walkover');
    });
    startBtn.disabled = !hasPending;
    startBtn.textContent = hasPending ? 'Start første kamp' : 'Ingen flere kamper';
    startBtn.focus();
  }
}

export function hideTournamentOverview(){
  if(!ensureElements()) return;
  closeModal('#tournamentOverviewMask');
  // Viktig: re-evaluer visning av «Neste sett»-knappen m.m. etter at oversikten lukkes.
  // updateScores viser knappen igjen hvis state.betweenSets === true.
  try { updateScores(); } catch(_) {}
}

function startFirstMatch(){
  // Set tournament mode
  state.playMode = 'tournament';
  
  // Lock tournament when first match starts (if configured)
  if(TOURNAMENT_LOCK_MODE === 'onFirstMatch' && state.tournamentData && !state.tournamentData.locked){
    state.tournamentData.locked = true;
  }

  // Finn første pending kamp (ikke completed/walkover)
  const matches = state.tournamentData?.matches || [];
  const matchStates = state.tournamentData?.matchStates || {};
  const firstPending = matches.find(m => {
    const st = matchStates[m.id];
    // Hvis ingen state: regn som pending
    if (!st) return true;
    return st.status !== 'completed' && st.status !== 'walkover';
  });

  // Ingen pending? Gi tydelig tilbakemelding og disable knappen.
  if (!firstPending) {
    try { 
      const btn = document.getElementById('tournamentOverviewStart');
      if (btn) { btn.disabled = true; btn.textContent = 'Ingen flere kamper'; }
    } catch(_) {}
    return;
  }

  // Start valgt kamp via eksisterende hjelpefunksjon
  handleStartMatch(firstPending.id);
}


export function renderTournamentOverview(){
  if(!state.tournamentData || !state.tournamentData.matches) {
    return;
  }

  const roundsElement = document.getElementById('tournamentRounds');
  if(!roundsElement) return;

  // Clear existing content
  roundsElement.innerHTML = '';

  const scrollTargetId = state.tournamentData.scrollTargetMatchId;
  let targetElement = null;

  // Group matches by round
  const matchesByRound = {};
  state.tournamentData.matches.forEach(match => {
    if(!matchesByRound[match.round]) {
      matchesByRound[match.round] = [];
    }
    matchesByRound[match.round].push(match);
  });

  // Render each round as a table
  Object.keys(matchesByRound).sort((a, b) => parseInt(a) - parseInt(b)).forEach(roundNumber => {
    // Round header
    const roundHeader = document.createElement('h4');
    roundHeader.className = 'tournament-round-header';
    roundHeader.textContent = `Runde ${roundNumber}`;
    roundsElement.appendChild(roundHeader);

    // Create table
    const table = document.createElement('table');
    table.className = 'tournament-table';

    // Table header
    const thead = document.createElement('thead');
    const headerRow = document.createElement('tr');
    headerRow.innerHTML = `
      <th>#</th>
      <th>Spillere</th>
      <th>Status</th>
      <th>Handling</th>
    `;
    thead.appendChild(headerRow);
    table.appendChild(thead);

    // Table body
    const tbody = document.createElement('tbody');
    const matchesFragment = document.createDocumentFragment();

    matchesByRound[roundNumber].forEach((match, index) => {
      const row = document.createElement('tr');
      row.dataset.matchId = match.id;

      const matchState = state.tournamentData.matchStates?.[match.id];
      const isCompleted = matchState?.status === 'completed';
      const isWalkover = matchState?.status === 'walkover';
      const isOngoing = matchState && !isCompleted && !isWalkover;
      const winner = isCompleted ? (matchState.finalScore.setsA > matchState.finalScore.setsB ? 'A' : 'B') :
                   isWalkover ? matchState.walkoverWinner : null;

      // Match number column
      const matchNumberCell = document.createElement('td');
      matchNumberCell.className = 'match-number';
      matchNumberCell.textContent = `#${index + 1}`;
      row.appendChild(matchNumberCell);

      // Players column
      const playersCell = document.createElement('td');
      playersCell.className = 'match-players';
      
      const playerA = document.createElement('span');
      playerA.className = 'player-name';
      playerA.textContent = match.playerA || 'TBD';
      if (winner === 'A') playerA.classList.add('winner-name');
      
      const vs = document.createElement('span');
      vs.className = 'vs';
      vs.textContent = 'vs';
      
      const playerB = document.createElement('span');
      playerB.className = 'player-name';
      playerB.textContent = match.playerB || 'TBD';
      if (winner === 'B') playerB.classList.add('winner-name');
      
      playersCell.appendChild(playerA);
      playersCell.appendChild(vs);
      playersCell.appendChild(playerB);
      row.appendChild(playersCell);

      // Status column
      const statusCell = document.createElement('td');
      statusCell.className = 'match-status-cell';
      
      if (!matchState) {
        statusCell.innerHTML = '<span class="status-waiting">Venter</span>';
      } else if (isCompleted) {
        const setScores = document.createElement('div');
        setScores.className = 'set-scores';
        
        if (matchState.finalScore && matchState.finalScore.setHistory) {
          matchState.finalScore.setHistory.forEach((set, setIndex) => {
            const setScore = document.createElement('span');
            setScore.className = 'set-score';
            
            // Create separate spans for each score to allow individual styling
            const scoreASpan = document.createElement('span');
            scoreASpan.textContent = set.a;
            if (winner === 'A' && set.a > set.b) scoreASpan.classList.add('winner-scores');
            
            const dashSpan = document.createElement('span');
            dashSpan.textContent = '-';
            
            const scoreBSpan = document.createElement('span');
            scoreBSpan.textContent = set.b;
            if (winner === 'B' && set.b > set.a) scoreBSpan.classList.add('winner-scores');
            
            setScore.appendChild(scoreASpan);
            setScore.appendChild(dashSpan);
            setScore.appendChild(scoreBSpan);
            setScores.appendChild(setScore);
          });
        }
        
        statusCell.appendChild(setScores);
        
        // Add status text using DOM manipulation
        const statusDiv = document.createElement('div');
        statusDiv.className = 'status-finished';
        statusDiv.textContent = 'Ferdig';
        statusCell.appendChild(statusDiv);
      } else if (isWalkover) {
        const winnerName = matchState.walkoverWinner === 'A' ? match.playerA : match.playerB;
        statusCell.innerHTML = `
          <div class="status-finished">Walkover</div>
          <div class="walkover-info">${winnerName} vant</div>
        `;
      } else {
        // Ongoing match
        const setScores = document.createElement('div');
        setScores.className = 'set-scores';
        
        // Show completed sets from setHistory
        const setHistory = Array.isArray(matchState.setHistory) ? matchState.setHistory : [];
        setHistory.forEach((set) => {
          const setScore = document.createElement('span');
          setScore.className = 'set-score';
          setScore.textContent = `${set.a}-${set.b}`;
          setScores.appendChild(setScore);
        });
        
        // Show current/live set
        const currentSetScore = document.createElement('span');
        currentSetScore.className = 'set-score current live-set';
        
        if (matchState.betweenSets === true) {
          // In pause between sets - show 0-0 with pulse
          currentSetScore.textContent = '0-0';
        } else {
          // Active set - show current scores
          const scoreA = matchState.scoreA ?? 0;
          const scoreB = matchState.scoreB ?? 0;
          currentSetScore.textContent = `${scoreA}-${scoreB}`;
        }
        
        setScores.appendChild(currentSetScore);
        statusCell.appendChild(setScores);
        
        // Add status text using DOM manipulation
        const statusDiv = document.createElement('div');
        statusDiv.className = 'status-ongoing';
        statusDiv.textContent = 'Pågår';
        statusCell.appendChild(statusDiv);
      }
      
      row.appendChild(statusCell);

      // Action column
      const actionCell = document.createElement('td');
      actionCell.className = 'match-action';
      
      const actionBtn = document.createElement('button');
      actionBtn.className = 'tournament-table-btn';
      actionBtn.dataset.matchId = match.id;

      if (isCompleted) {
        actionBtn.textContent = 'Ferdig';
        actionBtn.disabled = true;
        actionBtn.classList.add('disabled');
      } else if (isWalkover) {
        actionBtn.textContent = 'Walkover';
        actionBtn.disabled = true;
        actionBtn.classList.add('disabled');
      } else {
        actionBtn.textContent = 'Gå til kamp';
        actionBtn.addEventListener('click', () => handleStartMatch(match.id));
      }

      actionCell.appendChild(actionBtn);
      row.appendChild(actionCell);

      if (match.id === scrollTargetId) targetElement = row;
      matchesFragment.appendChild(row);
    });

    tbody.appendChild(matchesFragment);
    table.appendChild(tbody);
    roundsElement.appendChild(table);
  });

  // Scroll to target match if specified
  if (targetElement) {
    const scrollContainer = roundsElement.closest('.fullscreenPanel .panelBody') || roundsElement;
    requestAnimationFrame(function(){
      const offset = targetElement.offsetTop - 24; // litt headroom
      scrollContainer.scrollTo({ top: offset < 0 ? 0 : offset, behavior: 'smooth' });
      targetElement.classList.add('just-finished');
      setTimeout(() => targetElement.classList.remove('just-finished'), 1500);
      delete state.tournamentData.scrollTargetMatchId;
    });
  }
}

export function setupTournamentOverview(){
  bindEvents();
  if(!ensureElements()) return;
  mask.style.display = 'none';
  mask.setAttribute('aria-hidden', 'true');
}

// Internal function to handle starting a match
function handleStartMatch(matchId) {
  const match = state.tournamentData.matches.find(m => m.id === matchId);
  if (match) {
    import('./matchView.js').then(module => {
      module.startTournamentMatch(matchId);
    });
  }
}

// Make showTournamentOverview available globally
window.showTournamentOverview = showTournamentOverview;

export function renderTournamentOverviewFromSnapshot(tSnap, root){
  if(!ensureElements()) return;
  
  // Hide interactive controls for dashboard mode
  hideInteractiveControlsForDashboard();
  
  // Set tournament name if available
  if(nameElement && tSnap && tSnap.name) {
    nameElement.textContent = tSnap.name;
  }
  
  // Open modal
  openModal('#tournamentOverviewMask');
  
  // Get match states
  var ms = (tSnap && tSnap.matchStates) || {};
  var active = tSnap && tSnap.activeMatchId;
  
  // Render tournament overview
  renderDashboardTournamentOverview(ms, active, root);
}

function hideInteractiveControlsForDashboard(){
  if(!ensureElements()) return;
  
  // Hide back button
  if(backBtn) backBtn.style.display = 'none';
  
  // Hide start button
  if(startBtn) startBtn.style.display = 'none';
  
  // Hide close button
  if(closeBtn) closeBtn.style.display = 'none';
}

function renderDashboardTournamentOverview(matchStates, activeMatchId, root){
  const roundsElement = document.getElementById('tournamentRounds');
  if(!roundsElement) return;
  
  // Clear existing content
  roundsElement.innerHTML = '';
  
  // Group matches by round (we need to get matches from somewhere)
  // For now, create a simple list of all match states
  var matches = [];
  Object.keys(matchStates).forEach(function(matchId) {
    var matchState = matchStates[matchId];
    matches.push({
      id: matchId,
      playerA: matchState.playerA || 'TBD',
      playerB: matchState.playerB || 'TBD',
      round: matchState.round || 1,
      state: matchState
    });
  });
  
  // Group by round
  var matchesByRound = {};
  matches.forEach(function(match) {
    if(!matchesByRound[match.round]) {
      matchesByRound[match.round] = [];
    }
    matchesByRound[match.round].push(match);
  });
  
  // Render each round
  Object.keys(matchesByRound).sort(function(a, b) { return parseInt(a) - parseInt(b); }).forEach(function(roundNumber) {
    // Round header
    var roundHeader = document.createElement('h4');
    roundHeader.className = 'tournament-round-header';
    roundHeader.textContent = 'Runde ' + roundNumber;
    roundsElement.appendChild(roundHeader);
    
    // Create table
    var table = document.createElement('table');
    table.className = 'tournament-table';
    
    // Table header
    var thead = document.createElement('thead');
    var headerRow = document.createElement('tr');
    headerRow.innerHTML = '<th>#</th><th>Spillere</th><th>Status</th><th>Handling</th>';
    thead.appendChild(headerRow);
    table.appendChild(thead);
    
    // Table body
    var tbody = document.createElement('tbody');
    
    matchesByRound[roundNumber].forEach(function(match, index) {
      var row = document.createElement('tr');
      row.dataset.matchId = match.id;
      
      var matchState = match.state;
      var isActive = match.id === activeMatchId;
      var isCompleted = matchState.status === 'completed';
      var isWalkover = matchState.status === 'walkover';
      var isOngoing = matchState.status === 'in_progress';
      
      // Highlight active row
      if(isActive) {
        row.classList.add('active-match');
      }
      
      // Match number column
      var matchNumberCell = document.createElement('td');
      matchNumberCell.className = 'match-number';
      matchNumberCell.textContent = '#' + (index + 1);
      row.appendChild(matchNumberCell);
      
      // Players column
      var playersCell = document.createElement('td');
      playersCell.className = 'match-players';
      
      var playerA = document.createElement('span');
      playerA.className = 'player-name';
      playerA.textContent = match.playerA;
      if(isCompleted && matchState.finalScore && matchState.finalScore.setsA > matchState.finalScore.setsB) {
        playerA.classList.add('winner-name');
      }
      
      var vs = document.createElement('span');
      vs.className = 'vs';
      vs.textContent = 'vs';
      
      var playerB = document.createElement('span');
      playerB.className = 'player-name';
      playerB.textContent = match.playerB;
      if(isCompleted && matchState.finalScore && matchState.finalScore.setsB > matchState.finalScore.setsA) {
        playerB.classList.add('winner-name');
      }
      
      playersCell.appendChild(playerA);
      playersCell.appendChild(vs);
      playersCell.appendChild(playerB);
      row.appendChild(playersCell);
      
      // Status column
      var statusCell = document.createElement('td');
      statusCell.className = 'match-status-cell';
      
      if(!matchState || matchState.status === 'pending') {
        statusCell.innerHTML = '<span class="status-waiting">Venter</span>';
      } else if(isCompleted) {
        var setScores = document.createElement('div');
        setScores.className = 'set-scores';
        
        if(matchState.finalScore && matchState.finalScore.setHistory) {
          matchState.finalScore.setHistory.forEach(function(set) {
            var setScore = document.createElement('span');
            setScore.className = 'set-score';
            
            // Create separate spans for each score
            var scoreASpan = document.createElement('span');
            scoreASpan.textContent = set.a;
            if(set.a > set.b) scoreASpan.classList.add('winner-scores');
            
            var dashSpan = document.createElement('span');
            dashSpan.textContent = '-';
            
            var scoreBSpan = document.createElement('span');
            scoreBSpan.textContent = set.b;
            if(set.b > set.a) scoreBSpan.classList.add('winner-scores');
            
            setScore.appendChild(scoreASpan);
            setScore.appendChild(dashSpan);
            setScore.appendChild(scoreBSpan);
            setScores.appendChild(setScore);
          });
        }
        
        statusCell.appendChild(setScores);
        
        var statusDiv = document.createElement('div');
        statusDiv.className = 'status-finished';
        statusDiv.textContent = 'Ferdig';
        statusCell.appendChild(statusDiv);
      } else if(isWalkover) {
        var winnerName = matchState.walkoverWinner === 'A' ? match.playerA : match.playerB;
        statusCell.innerHTML = '<div class="status-finished">Walkover</div><div class="walkover-info">' + winnerName + ' vant</div>';
      } else if(isActive && root) {
        // Active match - show live scores from root
        var setScores = document.createElement('div');
        setScores.className = 'set-scores';
        
        // Show completed sets from setHistory
        var setHistory = Array.isArray(matchState.setHistory) ? matchState.setHistory : [];
        setHistory.forEach(function(set) {
          var setScore = document.createElement('span');
          setScore.className = 'set-score';
          setScore.textContent = set.a + '-' + set.b;
          setScores.appendChild(setScore);
        });
        
        // Show current/live set
        var currentSetScore = document.createElement('span');
        currentSetScore.className = 'set-score current live-set';
        
        if(matchState.betweenSets === true) {
          currentSetScore.textContent = '0-0';
        } else {
          var scoreA = root.scores ? root.scores.A : 0;
          var scoreB = root.scores ? root.scores.B : 0;
          currentSetScore.textContent = scoreA + '-' + scoreB;
        }
        
        setScores.appendChild(currentSetScore);
        statusCell.appendChild(setScores);
        
        var statusDiv = document.createElement('div');
        statusDiv.className = 'status-ongoing';
        statusDiv.textContent = 'Pågår';
        statusCell.appendChild(statusDiv);
      } else {
        statusCell.innerHTML = '<span class="status-waiting">Venter</span>';
      }
      
      row.appendChild(statusCell);
      
      // Action column (read-only)
      var actionCell = document.createElement('td');
      actionCell.className = 'match-action';
      
      var actionBtn = document.createElement('button');
      actionBtn.className = 'tournament-table-btn';
      actionBtn.disabled = true;
      
      if(isCompleted) {
        actionBtn.textContent = 'Ferdig';
        actionBtn.classList.add('disabled');
      } else if(isWalkover) {
        actionBtn.textContent = 'Walkover';
        actionBtn.classList.add('disabled');
      } else if(isActive) {
        actionBtn.textContent = 'Aktiv';
        actionBtn.classList.add('disabled');
      } else {
        actionBtn.textContent = 'Venter';
        actionBtn.classList.add('disabled');
      }
      
      actionCell.appendChild(actionBtn);
      row.appendChild(actionCell);
      
      tbody.appendChild(row);
    });
    
    table.appendChild(tbody);
    roundsElement.appendChild(table);
  });
}


--------------------------------------------------
File End
--------------------------------------------------


js\ui\tournamentSetup.js
File type: .js
﻿import { state, clearLiveState } from '../state/matchState.js';
// (fjernet ubrukte imports)
import { openModal, closeModal } from './modal.js';
import { hasActiveMatchState, getContinueLabel } from './session.js';
import { showSplash, setSplashContinueState, syncSplashButtons } from './splash.js';
import { goToStart } from '../main.js';
import { getRecentNames, getPrevNames } from '../services/storage.js';
import { saveIndividual } from '../services/namesStore.js';
import { generateSwissRoundOne } from '../services/tournament.js';
import { attachAutocomplete, toggleDropdownFor, updateDropdownButtons } from './autocomplete.js';
import { qs, on } from '../util/domUtils.js';

// Konfig: når turneringen låses
const TOURNAMENT_LOCK_MODE = 'onCreation'; // 'onCreation' | 'onFirstMatch'


let mask;
let modal;
let nameInput;
let list;
let addBtn;
let closeBtn;
let backBtn;
let continueBtn;

const draft = {
  name: 'Demo-turnering',
  participants: ['Alice', 'Bob', 'Charlie', 'Diana', 'Eve', 'Frank', 'Grace', 'Henry']
};

function ensureElements(){
  if(!mask) mask = document.getElementById('tournamentMask');
  if(!mask) return false;
  if(!modal) modal = mask.querySelector('.tournamentSetupPanel');
  if(!nameInput) nameInput = qs('#tournamentName');
  if(!list) list = qs('#tournamentParticipants');
  if(!addBtn) addBtn = qs('#tournamentAddParticipant');
  if(!closeBtn) closeBtn = qs('#tournamentClose');
  if(!backBtn) backBtn = qs('#tournamentBack');
  if(!continueBtn) continueBtn = qs('#tournamentContinue');
  return true;
}

function bindEvents(){
  if(!ensureElements()) return;
  if(mask.dataset.bound) return;
  mask.dataset.bound = '1';

  if(addBtn){
    on(addBtn, 'click', function(){
      addParticipantRow('');
    });
  }

  if(closeBtn){
    on(closeBtn, 'click', function(){
      hideTournamentSetup();
      goToStart({ from: 'setup' });
    });
  }

  if(backBtn){
    on(backBtn, 'click', function(){
      hideTournamentSetup();
      goToStart({ from: 'setup' });
    });
  }

  if(nameInput){
    on(nameInput, 'input', function(){
      draft.name = nameInput.value;
      updateContinueButton();
    });
  }

  if(continueBtn){
    continueBtn.addEventListener('click', function(){
      // Save participant names to the same storage as single match names
      saveTournamentParticipants();
      hideTournamentSetup();
      // Start the match with tournament mode
      startTournamentMatch();
    });
  }
}

function addParticipantRow(value){
  if(!ensureElements()) return;
  const li = document.createElement('li');
  li.className = 'participantRow';

  // Create autocomplete wrapper
  const autocompleteWrapper = document.createElement('div');
  autocompleteWrapper.className = 'autocomplete';

  const input = document.createElement('input');
  input.type = 'text';
  input.className = 'participantInput';
  input.placeholder = 'Deltaker ' + (list.children.length + 1);
  if(value) input.value = value;

  // Set unique ID for input BEFORE creating autocomplete list
  input.id = 'participant' + Date.now() + Math.random().toString(36).substr(2, 9);

  // Create dropdown button
  const dropdownBtn = document.createElement('button');
  dropdownBtn.type = 'button';
  dropdownBtn.className = 'dropdown-btn';
  dropdownBtn.innerHTML = '&#x25BC;';
  dropdownBtn.onclick = function() { window.toggleTournamentDropdown(input.id); };

  // Create autocomplete list
  const autocompleteList = document.createElement('div');
  autocompleteList.id = input.id + '-list';
  autocompleteList.className = 'autocomplete-items';

  input.addEventListener('input', function(){
    persistParticipants();
    updateContinueButton();
  });
  
  // Save name to storage when user types (for autocomplete)
  input.addEventListener('blur', function(){
    const name = this.value.trim();
    if(name && name.length > 0){
      saveIndividual(name);
      updateDropdownButtons('#tournamentMask');
    }
  });

  // Add autocomplete functionality using shared helper
  attachAutocomplete(input, {
    listEl: autocompleteList,
    onSelect: () => {
      persistParticipants();
      updateContinueButton();
      updateDropdownButtons('#tournamentMask');
    }
  });

  // Assemble autocomplete wrapper
  autocompleteWrapper.appendChild(input);
  autocompleteWrapper.appendChild(dropdownBtn);
  autocompleteWrapper.appendChild(autocompleteList);

  const removeBtn = document.createElement('button');
  removeBtn.type = 'button';
  removeBtn.className = 'participantRemove';
  removeBtn.textContent = 'Fjern';
  removeBtn.addEventListener('click', function(){
    list.removeChild(li);
    persistParticipants();
    renumberPlaceholders();
    updateContinueButton();
  });

  li.appendChild(autocompleteWrapper);
  li.appendChild(removeBtn);
  list.appendChild(li);
  input.focus();
  persistParticipants();
  updateContinueButton();
  updateDropdownButtons('#tournamentMask'); // oppdater lokalt innenfor turneringsmodal
}

function persistParticipants(){
  if(!list) return;
  draft.participants = Array.from(list.querySelectorAll('.participantInput')).map(function(input){
    return input.value.trim();
  });
}

function renumberPlaceholders(){
  if(!list) return;
  Array.from(list.querySelectorAll('.participantInput')).forEach(function(input, idx){
    if(!input.value){
      input.placeholder = 'Deltaker ' + (idx + 1);
    }
  });
}

function updateContinueButton(){
  if(!continueBtn) return;
  const filled = draft.participants.filter(function(name){ return name.length > 0; });
  continueBtn.disabled = filled.length < 2 || !(draft.name && draft.name.trim().length);
}

export function showTournamentSetup(){
  if(!ensureElements()) return;
  
  // Guard: blokker tilgang til setup når turneringen er låst
  if(state.tournamentData && state.tournamentData.locked){
    // Redirect til oversikt hvis noen prøver å gå direkte hit via URL/historikk
    import('./tournamentOverview.js').then(function(module){
      module.showTournamentOverview();
    });
    return;
  }
  
  state.allowScoring = false;
  document.body.classList.remove('areas-active');

  openModal('#tournamentMask');

  // Clear existing participants if any
  if(list.children.length > 0){
    list.innerHTML = '';
  }

  // Add participants from draft
  if(draft.participants && draft.participants.length > 0){
    draft.participants.forEach(name => {
      addParticipantRow(name);
    });
  } else {
    // Fallback: add empty rows if no participants
    addParticipantRow('');
    addParticipantRow('');
  }

  // Set tournament name
  if(nameInput){
    nameInput.value = draft.name || '';
    if(!draft.name){
      nameInput.placeholder = 'Turneringsnavn';
    }
  }

  renumberPlaceholders();
  updateContinueButton();
  updateDropdownButtons('#tournamentMask'); // oppdater lokalt innenfor turneringsmodal
  if(nameInput) nameInput.focus();
}

export function hideTournamentSetup(){
  if(!ensureElements()) return;
  closeModal('#tournamentMask');
}

export function toggleTournamentDropdown(inputId){
  const input = document.getElementById(inputId);
  const list = document.getElementById(inputId + '-list');
  const dropdownBtn = input?.parentElement?.querySelector('.dropdown-btn');
  
  if(!input || !list) return;
  
  // Don't show dropdown if button is hidden (no saved names)
  if(dropdownBtn && dropdownBtn.classList.contains('hidden')) return;

  toggleDropdownFor(input, list, () => getRecentNames(8));
}


export function setupTournamentSetup(){
  bindEvents();
  if(!ensureElements()) return;
  mask.style.display = 'none';
  mask.setAttribute('aria-hidden', 'true');
}

function saveTournamentParticipants(){
  if(!list) return;
  
  // ELEGANT: Clear any existing match state before creating tournament
  // This prevents single match data from leaking into tournament mode
  console.log('[TOURNAMENT SETUP] Clearing existing match state before tournament creation');
  
  // Reset match state to clean slate
  state.scoreA = 0;
  state.scoreB = 0;
  state.setsA = 0;
  state.setsB = 0;
  state.currentSet = 1;
  state.swappedAt11 = false;
  state.locked = false;
  state.betweenSets = false;
  state.pendingSetWinner = null;
  state.setHistory = [];
  state.allowScoring = false;
  state.nameEditMode = false;
  
  // Clear localStorage to prevent restoration of old single match data
  clearLiveState(true); // Force clear even in tournament mode
  
  // Get all participant names
  const participants = Array.from(list.querySelectorAll('.participantInput')).map(function(input){
    return input.value.trim();
  }).filter(function(name){ return name.length > 0; });
  
  // Save each participant name to the same storage as single match names
  participants.forEach(saveIndividual);
  
  // Generate Swiss tournament Round 1 matches with placeholder rounds
  const tournamentData = generateSwissRoundOne(participants);
  
  // Store tournament data for later use
  state.tournamentData = {
    name: draft.name,
    participants: participants,
    matches: tournamentData.round1.concat(tournamentData.placeholderRounds),
    matchStates: {},
    locked: TOURNAMENT_LOCK_MODE === 'onCreation' ? true : false
  };
  
  // Oppdater dropdown-knapper etter lagring av navn
  updateDropdownButtons('#tournamentMask');
}

function startTournamentMatch(){
  // Import and show tournament overview instead of starting match directly
  import('./tournamentOverview.js').then(function(module){
    module.renderTournamentOverview();
    module.showTournamentOverview();
  });
}

// Make toggleTournamentDropdown available globally
window.toggleTournamentDropdown = toggleTournamentDropdown;



--------------------------------------------------
File End
--------------------------------------------------


js\util\domUtils.js
File type: .js
// js/util/domUtils.js
// Små, generelle DOM-helper funksjoner

export const qs = (s, r=document) => r.querySelector(s);
export const qsa = (s, r=document) => Array.from(r.querySelectorAll(s));
export const on = (el, t, fn, opts) => { el.addEventListener(t, fn, opts); return () => el.removeEventListener(t, fn, opts); };
export const toggle = (el, cls, on) => el && (on ? el.classList.add(cls) : el.classList.remove(cls));
export const reflow = (el) => { if (el) void el.offsetHeight; };



--------------------------------------------------
File End
--------------------------------------------------


js\util\loadScript.js
File type: .js
// js/util/loadScript.js
// Felles utility for dynamisk skriptlasting

export function loadScript(src){
  return new Promise(function(resolve, reject){
    var s = document.createElement('script');
    s.src = src;
    s.async = true;
    s.onload = function(){ resolve(); };
    s.onerror = function(){ reject(new Error('load '+src)); };
    document.head.appendChild(s);
  });
}

export function loadScriptOnce(src){
  return new Promise(function(resolve, reject){
    if(document.querySelector('script[data-dyn="'+src+'"]')){
      resolve();
      return;
    }
    var s = document.createElement('script');
    s.src = src;
    s.async = true;
    s.setAttribute('data-dyn', src);
    s.onload = function(){ resolve(); };
    s.onerror = function(){ reject(new Error('load-fail')); };
    document.head.appendChild(s);
  });
}



--------------------------------------------------
File End
--------------------------------------------------


scripts\loc-count.mjs
File type: .mjs
import { readdirSync, statSync, readFileSync } from 'node:fs';
import { join, extname } from 'node:path';

// Konfig: hvilke filer som telles (enkelt og eksplisitt)
const COUNT_EXTS = new Set(['.js', '.ts', '.css', '.html', '.md']);
const EXCLUDE_DIRS = new Set(['node_modules', '.git', 'dist', 'build', 'coverage', '.cache', '.github', 'assets', 'public']);

function shouldSkipDir(name){ return EXCLUDE_DIRS.has(name); }
function shouldCountFile(file){ return COUNT_EXTS.has(extname(file).toLowerCase()); }

function walk(dir){
  let total = 0;
  for(const name of readdirSync(dir)){
    const p = join(dir, name);
    const st = statSync(p);
    if(st.isDirectory()){
      if(shouldSkipDir(name)) continue;
      total += walk(p);
    }else{
      if(!shouldCountFile(p)) continue;
      const content = readFileSync(p, 'utf8');
      // Teller antall linjer (inkl. tomme) – rask og deterministisk
      total += content.split('\n').length;
    }
  }
  return total;
}

const root = process.cwd();
const total = walk(root);
console.log(total);


--------------------------------------------------
File End
--------------------------------------------------
